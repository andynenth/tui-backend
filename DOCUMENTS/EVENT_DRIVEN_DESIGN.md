# Event-Driven State Machine Design

**Date**: 2025-06-30  
**Branch**: event-driven  
**Target**: Complete event-driven architecture specification

## ðŸŽ¯ Core Design Principles

### 1. **Immediate Event Processing**
- **NO** polling loops or continuous checking
- **NO** `asyncio.sleep()` in state logic
- **Immediate** event â†’ state change â†’ broadcast

### 2. **Separation of Concerns**
- **State Logic**: Immediate, deterministic transitions
- **Display Timing**: Separate UI phases, no logic impact
- **Event Processing**: Serialized, race-condition free

### 3. **Managed Async Lifecycle**
- **NO** detached `asyncio.create_task()` calls
- **Proper** task cleanup on state transitions
- **Managed** timer lifecycle

## ðŸ”„ Event Types Definition

### User Events (High Priority)
These events come directly from user interactions and require immediate processing.

```python
class UserEvent:
    """Events triggered by direct user actions"""
    
    PLAY_PIECES = "play_pieces"        # Player selects pieces to play
    DECLARE = "declare"                # Player declares pile count
    REDEAL_REQUEST = "redeal_request"  # Player requests redeal (weak hand)
    DISCONNECT = "disconnect"          # Player loses connection
    RECONNECT = "reconnect"           # Player reconnects
    CONTINUE_ROUND = "continue_round" # Manual advance from display phases
```

**Characteristics**:
- **Immediate Processing**: No delays, process as received
- **State Validation**: Must validate against current game state
- **Frontend Response**: Immediate success/failure feedback

### System Events (High Priority)
These events are generated by the game logic itself and trigger state transitions.

```python
class SystemEvent:
    """Events generated by game logic"""
    
    # Turn-related events
    TURN_COMPLETE = "turn_complete"           # All players have played pieces
    TURN_WINNER_DETERMINED = "turn_winner"   # Winner calculation complete
    PIECES_TRANSFERRED = "pieces_transferred" # Winner takes all pieces
    
    # Round-related events  
    ROUND_COMPLETE = "round_complete"         # All hands empty
    ALL_DECLARED = "all_declared"             # All players declared
    
    # Game-related events
    GAME_COMPLETE = "game_complete"           # Win condition met
    ALL_HANDS_EMPTY = "all_hands_empty"       # No more pieces to play
    WIN_CONDITION_MET = "win_condition_met"   # Player reached 50+ points
    
    # Setup events
    CARDS_DEALT = "cards_dealt"               # Initial deal complete
    WEAK_HANDS_RESOLVED = "weak_hands_resolved" # All redeal decisions made
    SCORES_CALCULATED = "scores_calculated"   # Round scoring complete
    
    # Validation events
    VALID_PLAY_CONFIRMED = "valid_play_confirmed"     # Play validated by rules
    INVALID_PLAY_DETECTED = "invalid_play_detected"   # Rule violation found
```

**Characteristics**:
- **Logic Triggers**: Generated when game conditions met
- **Immediate Transitions**: Cause immediate state changes
- **Deterministic**: Predictable, condition-based
- **Validation**: Include rule enforcement events

### Timer Events (Medium Priority - Display Only)
These events handle UI timing but do NOT affect game logic.

```python
class TimerEvent:
    """Events for UI timing only - NO LOGIC IMPACT"""
    
    DISPLAY_DELAY_COMPLETE = "display_delay_complete"  # Display timing finished
    UI_ANIMATION_COMPLETE = "ui_animation_complete"    # Frontend animation done
    AUTO_ADVANCE_READY = "auto_advance_ready"          # UI ready for next phase
    
    # Specific display phases
    TURN_RESULTS_DISPLAY_COMPLETE = "turn_results_display_complete"   # 7s turn display
    SCORING_DISPLAY_COMPLETE = "scoring_display_complete"             # 7s scoring display
    CARD_DEAL_ANIMATION_COMPLETE = "card_deal_animation_complete"     # Deal animation
    PIECE_MOVE_ANIMATION_COMPLETE = "piece_move_animation_complete"   # Piece animations
    
    # User experience events  
    NOTIFICATION_DISMISSED = "notification_dismissed"   # User dismissed notification
    TUTORIAL_STEP_COMPLETE = "tutorial_step_complete"   # Tutorial progression
```

**Characteristics**:
- **Display Only**: Never affect game state logic
- **Optional**: Game continues without these events
- **UI Enhancement**: Improve user experience only
- **Parallel Processing**: Run alongside logic without blocking

### State Events (Medium Priority)
These events manage state machine lifecycle and transitions.

```python
class StateEvent:
    """Events for state machine lifecycle"""
    
    # State lifecycle events
    PHASE_ENTERED = "phase_entered"           # State setup complete
    PHASE_EXITING = "phase_exiting"          # State cleanup starting
    TRANSITION_READY = "transition_ready"     # Ready for state change
    SETUP_COMPLETE = "setup_complete"        # State initialization done
    CLEANUP_COMPLETE = "cleanup_complete"    # State cleanup finished
    
    # State validation events
    TRANSITION_VALIDATED = "transition_validated"     # Transition conditions met
    TRANSITION_BLOCKED = "transition_blocked"         # Invalid transition attempted
    STATE_SYNC_REQUIRED = "state_sync_required"       # State needs synchronization
    
    # Task management events
    ASYNC_TASK_STARTED = "async_task_started"         # Background task initiated
    ASYNC_TASK_COMPLETED = "async_task_completed"     # Background task finished
    ASYNC_TASK_CANCELLED = "async_task_cancelled"     # Task cancelled during cleanup
    
    # Error handling events
    STATE_ERROR = "state_error"                       # State processing error
    RECOVERY_INITIATED = "recovery_initiated"         # Error recovery started
    STATE_CORRUPTED = "state_corrupted"               # State inconsistency detected
```

**Characteristics**:
- **Lifecycle Management**: Control state transitions
- **Async Coordination**: Manage async task cleanup
- **State Validation**: Ensure proper state machine flow
- **Error Handling**: Recover from state inconsistencies
- **Task Tracking**: Monitor background async operations

## ðŸ—ï¸ Event-Driven Architecture Components

### 1. Event Processor
```python
class EventProcessor:
    """Central event processing engine - replaces polling loop"""
    
    def __init__(self, state_machine: GameStateMachine):
        self.state_machine = state_machine
        self.event_queue = asyncio.Queue()
        self.processing_lock = asyncio.Lock()
        
    async def handle_event(self, event: GameEvent) -> EventResult:
        """Process single event immediately - NO POLLING"""
        async with self.processing_lock:  # Prevent race conditions
            # Validate event against current state
            if not self._validate_event(event):
                return EventResult(success=False, reason="Invalid event")
            
            # Process event immediately
            result = await self.state_machine.current_state.process_event(event)
            
            # Trigger immediate transition if needed
            if result.triggers_transition:
                await self._immediate_transition(result.target_state, result.reason)
            
            return result
    
    async def _immediate_transition(self, target_state: GamePhase, reason: str):
        """Immediate state transition - NO DELAYS"""
        await self.state_machine.trigger_transition(target_state, reason)
```

### 2. Game Event Class
```python
@dataclass
class GameEvent:
    """Unified event structure"""
    
    event_type: str           # "user", "system", "timer", "state"
    trigger: str              # Specific event trigger
    data: Dict[str, Any]      # Event payload
    player_name: Optional[str] = None
    timestamp: float = field(default_factory=time.time)
    immediate: bool = True    # True for logic events, False for display
    sequence_id: int = 0      # For event ordering
    
class EventResult:
    """Result of event processing"""
    
    success: bool
    triggers_transition: bool = False
    target_state: Optional[GamePhase] = None
    reason: str = ""
    data: Dict[str, Any] = field(default_factory=dict)
```

### 3. State Interface Update
```python
class GameState(ABC):
    """Updated base state for event-driven processing"""
    
    @abstractmethod
    async def process_event(self, event: GameEvent) -> EventResult:
        """Process event and return immediate result - NO POLLING"""
        pass
    
    def get_valid_events(self) -> Set[str]:
        """Return set of valid event triggers for this state"""
        pass
    
    async def check_immediate_transitions(self) -> Optional[GamePhase]:
        """Check for immediate transitions - REPLACES POLLING"""
        pass
```

## ðŸ”„ Event-Driven State Transitions

### Current Polling Pattern (âŒ TO REMOVE)
```python
# CURRENT - POLLING BASED
while self.is_running:
    # Process actions
    await self.process_pending_actions()
    
    # POLL for transition conditions  
    if self.current_state:
        next_phase = await self.current_state.check_transition_conditions()  # â† POLLING
        if next_phase:
            await self._transition_to(next_phase)
    
    await asyncio.sleep(0.1)  # â† POLLING DELAY
```

### Target Event-Driven Pattern (âœ… TARGET)
```python
# TARGET - EVENT DRIVEN
async def handle_action(self, action: GameAction) -> Dict:
    """Convert action to event and process immediately"""
    
    # Create event from action
    event = GameEvent(
        event_type="user",
        trigger=action.action_type.value,
        data=action.payload,
        player_name=action.player_name,
        immediate=True
    )
    
    # Process immediately - NO POLLING
    result = await self.event_processor.handle_event(event)
    
    return {
        "success": result.success,
        "immediate": True,
        "transition": result.triggers_transition
    }
```

## ðŸ“‹ State-Specific Event Triggers

### TurnState Events
```python
class TurnState(GameState):
    
    async def process_event(self, event: GameEvent) -> EventResult:
        """Event-driven turn processing"""
        
        if event.trigger == "play_pieces":
            # Process piece play immediately
            result = await self._handle_play_pieces(event.data)
            
            # Check immediate transition condition
            if self._all_players_played():
                # Create system event for turn completion
                system_event = GameEvent(
                    event_type="system",
                    trigger="turn_complete",
                    data={"winner": self.winner, "plays": self.turn_plays}
                )
                
                return EventResult(
                    success=True,
                    triggers_transition=True,
                    target_state=GamePhase.TURN_RESULTS,
                    reason="All players played - turn complete"
                )
        
        return EventResult(success=True, triggers_transition=False)
```

### ScoringState Events  
```python
class ScoringState(GameState):
    
    async def process_event(self, event: GameEvent) -> EventResult:
        """Event-driven scoring processing"""
        
        if event.trigger == "phase_entered":
            # Calculate scores immediately
            await self._calculate_scores()
            
            # Check immediate transition condition
            if self.game_complete:
                return EventResult(
                    success=True,
                    triggers_transition=False,  # Game ends, no transition
                    reason="Game complete"
                )
            else:
                return EventResult(
                    success=True,
                    triggers_transition=True,
                    target_state=GamePhase.PREPARATION,
                    reason="Scores calculated - start next round"
                )
```

### DeclarationState Events
```python
class DeclarationState(GameState):
    
    async def process_event(self, event: GameEvent) -> EventResult:
        """Event-driven declaration processing"""
        
        if event.trigger == "declare":
            # Process declaration immediately
            await self._handle_declaration(event.data)
            
            # Check immediate transition condition
            if self._all_players_declared():
                return EventResult(
                    success=True,
                    triggers_transition=True,
                    target_state=GamePhase.TURN,
                    reason="All players declared - start turn"
                )
        
        return EventResult(success=True, triggers_transition=False)
```

## ðŸŽ¨ Display vs Logic Separation

### Logic Events (Immediate)
```python
# These events trigger immediate state changes
LOGIC_EVENTS = {
    "play_pieces",      # â†’ Check turn completion
    "declare",          # â†’ Check all declared  
    "turn_complete",    # â†’ Transition to TURN_RESULTS
    "all_declared",     # â†’ Transition to TURN
    "round_complete",   # â†’ Transition to SCORING
    "scores_calculated" # â†’ Transition to PREPARATION
}
```

### Display Events (Non-blocking)
```python
# These events only affect UI timing
DISPLAY_EVENTS = {
    "display_delay_complete",  # UI timing only
    "animation_complete",      # Frontend animation
    "auto_advance_ready"       # User experience
}
```

### Separation Architecture
```python
class DisplayPhase:
    """Separate phase for UI timing - NO LOGIC IMPACT"""
    
    def __init__(self, logic_phase: GamePhase, display_duration: float):
        self.logic_phase = logic_phase      # The actual game state
        self.display_duration = display_duration
        self.display_timer: Optional[asyncio.Task] = None
    
    async def start_display(self):
        """Start display timer - PARALLEL to logic"""
        self.display_timer = asyncio.create_task(self._display_delay())
    
    async def cleanup(self):
        """Proper cleanup of display timer"""
        if self.display_timer and not self.display_timer.done():
            self.display_timer.cancel()
            try:
                await self.display_timer
            except asyncio.CancelledError:
                pass
```

## âš¡ Performance Benefits

### Current Polling Performance
- **CPU Usage**: 10 polls/second continuously
- **Latency**: 100-200ms delays
- **Memory**: Growing task references  
- **Race Conditions**: High risk

### Event-Driven Performance  
- **CPU Usage**: Only when events occur (~95% reduction)
- **Latency**: <10ms immediate processing  
- **Memory**: Managed task lifecycle
- **Race Conditions**: Eliminated via serialization

## ðŸš€ Phase 2.2: Immediate Transition Architecture

### Current Polling Architecture (âŒ TO REMOVE)

**Problem Pattern in GameStateMachine**:
```python
# Current polling loop (lines 93-119 in game_state_machine.py)
async def _process_loop(self):
    while self.is_running:
        # Process actions
        await self.process_pending_actions()
        
        # POLL for transition conditions
        if self.current_state:
            next_phase = await self.current_state.check_transition_conditions()  # â† POLLING
            if next_phase:
                await self._transition_to(next_phase)
        
        await asyncio.sleep(0.1)  # â† POLLING DELAY
```

**Issues**:
- **Continuous Polling**: 10 checks/second even when idle
- **100ms Delays**: Up to 100ms latency for state transitions
- **CPU Waste**: Background processing when no events occur
- **Race Conditions**: Multiple paths can trigger same transition

### Target Event-Driven Architecture (âœ… TARGET)

**Event-Driven State Machine Core**:
```python
class GameStateMachine:
    def __init__(self, game, broadcast_callback=None):
        self.event_processor = EventProcessor(self)
        self.transition_lock = asyncio.Lock()  # Prevent race conditions
        self.active_tasks = set()              # Managed task lifecycle
        # Remove _process_task and polling loop entirely
    
    async def handle_action(self, action: GameAction) -> Dict:
        """Convert action to event and process immediately - NO POLLING"""
        
        # Create event from action
        event = GameEvent(
            event_type="user",
            trigger=action.action_type.value,
            data=action.payload,
            player_name=action.player_name,
            immediate=True
        )
        
        # Process immediately - NO POLLING DELAYS
        result = await self.event_processor.handle_event(event)
        
        return {
            "success": result.success,
            "immediate": True,
            "transition": result.triggers_transition,
            "data": result.data
        }
    
    async def trigger_immediate_transition(self, event: GameEvent) -> bool:
        """Immediate state transition based on event - NO POLLING"""
        async with self.transition_lock:  # Prevent concurrent transitions
            
            # Validate transition immediately
            if not self._validate_transition_for_event(event):
                return False
            
            # Get target state from event
            target_state = self._get_target_state_for_event(event)
            if not target_state:
                return False
            
            # Immediate transition - NO DELAYS
            await self._atomic_transition_to(target_state, event.trigger)
            return True
```

### Event Processing Pipeline (âœ… TARGET)

**Immediate Event Processing**:
```python
class EventProcessor:
    async def handle_event(self, event: GameEvent) -> EventResult:
        """Process event immediately with zero polling delays"""
        
        # 1. Immediate validation
        if not self._validate_event_for_current_state(event):
            return EventResult(success=False, reason="Invalid for current state")
        
        # 2. Process event in current state
        result = await self.state_machine.current_state.process_event(event)
        
        # 3. Check immediate transition conditions
        if result.triggers_transition:
            transition_success = await self.state_machine.trigger_immediate_transition(
                GameEvent(
                    event_type="system",
                    trigger=result.transition_trigger,
                    data=result.data,
                    immediate=True
                )
            )
            result.transition_completed = transition_success
        
        return result
```

### Async Task Lifecycle Management (âœ… TARGET)

**Managed Task Pattern**:
```python
class GameStateMachine:
    async def create_managed_task(self, coro, task_name: str) -> asyncio.Task:
        """Create task with proper lifecycle management"""
        task = asyncio.create_task(coro, name=task_name)
        self.active_tasks.add(task)
        
        # Auto-cleanup when task completes
        task.add_done_callback(lambda t: self.active_tasks.discard(t))
        return task
    
    async def cleanup_all_tasks(self):
        """Clean up all active tasks during state transitions"""
        if self.active_tasks:
            print(f"ðŸ§¹ Cleaning up {len(self.active_tasks)} active tasks")
            
            # Cancel all active tasks
            for task in self.active_tasks.copy():
                if not task.done():
                    task.cancel()
            
            # Wait for cancellation to complete
            if self.active_tasks:
                await asyncio.gather(*self.active_tasks, return_exceptions=True)
            
            self.active_tasks.clear()
    
    async def _atomic_transition_to(self, new_phase: GamePhase, reason: str):
        """Atomic state transition with proper cleanup"""
        
        # 1. Cleanup current state tasks
        await self.cleanup_all_tasks()
        
        # 2. Exit current state
        if self.current_state:
            await self.current_state.on_exit()
        
        # 3. Atomic state update
        old_phase = self.current_phase
        self.current_phase = new_phase
        self.current_state = self.states[new_phase]
        
        # 4. Enter new state
        await self.current_state.on_enter()
        
        # 5. Broadcast change (enterprise architecture)
        await self._broadcast_phase_change_with_hands(new_phase)
        
        # 6. Store event for replay
        await self._store_phase_change_event(old_phase, new_phase)
```

### State Change Validation Without Polling (âœ… TARGET)

**Event-Driven Validation**:
```python
class GameState(ABC):
    @abstractmethod
    async def process_event(self, event: GameEvent) -> EventResult:
        """Process event and check immediate transition conditions"""
        pass
    
    def get_immediate_transition_conditions(self) -> Dict[str, Callable]:
        """Return conditions that trigger immediate transitions"""
        return {}
    
    async def check_immediate_transition(self, event: GameEvent) -> Optional[GamePhase]:
        """Check transition conditions immediately - REPLACES POLLING"""
        conditions = self.get_immediate_transition_conditions()
        
        for trigger, condition_func in conditions.items():
            if event.trigger == trigger and condition_func():
                return self._get_target_phase_for_trigger(trigger)
        
        return None

# Example: TurnState immediate transitions
class TurnState(GameState):
    def get_immediate_transition_conditions(self) -> Dict[str, Callable]:
        return {
            "play_pieces": lambda: self._all_players_played(),
            "turn_complete": lambda: True,  # Always transition on turn_complete
        }
    
    async def process_event(self, event: GameEvent) -> EventResult:
        if event.trigger == "play_pieces":
            # Process piece play
            result = await self._handle_play_pieces(event.data)
            
            # Check immediate transition
            if self._all_players_played():
                return EventResult(
                    success=True,
                    triggers_transition=True,
                    transition_trigger="turn_complete",
                    data={"winner": self.turn_winner, "plays": self.turn_plays}
                )
        
        return EventResult(success=True, triggers_transition=False)
```

### Display vs Logic Separation Architecture (âœ… TARGET)

**Frontend-Driven Display Timing (MANDATORY APPROACH)**:
```python
class GameStateMachine:
    """Event-driven state machine with frontend display delegation"""
    
    async def handle_turn_completion(self, turn_data: Dict):
        """IMMEDIATE logic processing with frontend display instructions"""
        
        # 1. IMMEDIATE: Process game logic (NO DELAYS)
        winner = await self._determine_turn_winner(turn_data)
        await self._transfer_pieces_to_winner(winner, turn_data["pieces"])
        
        # 2. IMMEDIATE: Determine next logic state
        if self._all_hands_empty():
            next_phase = GamePhase.SCORING
        else:
            next_phase = GamePhase.TURN
        
        # 3. IMMEDIATE: Broadcast with display metadata (NOT backend timing)
        await self.broadcast_event("turn_completed", {
            "winner": winner.name,
            "pieces_transferred": len(turn_data["pieces"]),
            "turn_results": self._get_turn_results(),
            
            # Frontend display instructions (CRITICAL: No backend delays)
            "display": {
                "type": "turn_results",
                "show_for_seconds": 7.0,
                "auto_advance": True,
                "can_skip": True,
                "next_phase": next_phase.value
            },
            
            # Logic state (already processed)
            "logic_complete": True,
            "immediate": True
        })
        
        # 4. IMMEDIATE: Transition backend state (frontend handles display)
        await self._immediate_transition_to(next_phase, "Turn completed - frontend displays results")
    
    async def handle_scoring_completion(self, scores: Dict):
        """IMMEDIATE scoring with frontend display delegation"""
        
        # 1. IMMEDIATE: Calculate scores and check win condition
        final_scores = await self._calculate_round_scores(scores)
        game_complete = await self._check_win_condition(final_scores)
        
        # 2. IMMEDIATE: Determine next state
        next_phase = GamePhase.GAME_END if game_complete else GamePhase.PREPARATION
        
        # 3. IMMEDIATE: Broadcast with frontend display instructions
        await self.broadcast_event("scoring_completed", {
            "scores": final_scores,
            "round_number": self.game.round_number,
            "game_complete": game_complete,
            
            # Frontend display instructions (NO backend timing)
            "display": {
                "type": "scoring_display",
                "show_for_seconds": 7.0,
                "auto_advance": True,
                "can_skip": True,
                "next_phase": next_phase.value
            },
            
            "logic_complete": True,
            "immediate": True
        })
        
        # 4. IMMEDIATE: Transition backend state
        await self._immediate_transition_to(next_phase, "Scoring complete - frontend displays results")

# CRITICAL: NO MORE BACKEND DISPLAY DELAYS
# All asyncio.sleep() for display timing REMOVED from backend
# Frontend handles ALL display timing independently
```

**Frontend Display Manager (MANDATORY IMPLEMENTATION)**:
```javascript
class FrontendDisplayManager {
    constructor(gameEventManager) {
        this.gameEventManager = gameEventManager;
        this.activeDisplays = new Map();
        this.setupCriticalEventHandlers();
    }
    
    setupCriticalEventHandlers() {
        // CRITICAL: Handle immediate backend events with frontend timing
        this.gameEventManager.on('turn_completed', (data) => {
            this.handleTurnResults(data);
        });
        
        this.gameEventManager.on('scoring_completed', (data) => {
            this.handleScoringDisplay(data);
        });
    }
    
    handleTurnResults(data) {
        const displayConfig = data.display;
        
        // Show turn results immediately (backend already transitioned)
        this.renderTurnResultsPage(data.turn_results);
        
        // FRONTEND controls timing (NOT backend)
        const displayTimer = setTimeout(() => {
            this.advanceToNextPhase(displayConfig.next_phase);
        }, displayConfig.show_for_seconds * 1000);
        
        // Store for skip functionality
        const displayId = `turn_results_${Date.now()}`;
        this.activeDisplays.set(displayId, {
            timer: displayTimer,
            config: displayConfig,
            type: 'turn_results'
        });
        
        // Add skip button (user control)
        if (displayConfig.can_skip) {
            this.addSkipButton(displayId);
        }
    }
    
    handleScoringDisplay(data) {
        const displayConfig = data.display;
        
        // Show scoring immediately (backend already transitioned)
        this.renderScoringPage(data.scores);
        
        // FRONTEND controls timing
        const displayTimer = setTimeout(() => {
            this.advanceToNextPhase(displayConfig.next_phase);
        }, displayConfig.show_for_seconds * 1000);
        
        const displayId = `scoring_display_${Date.now()}`;
        this.activeDisplays.set(displayId, {
            timer: displayTimer,
            config: displayConfig,
            type: 'scoring_display'
        });
        
        if (displayConfig.can_skip) {
            this.addSkipButton(displayId);
        }
    }
    
    skipCurrentDisplay() {
        // Allow users to skip display timing
        for (const [displayId, display] of this.activeDisplays) {
            if (display.config.can_skip) {
                clearTimeout(display.timer);
                this.advanceToNextPhase(display.config.next_phase);
                this.activeDisplays.delete(displayId);
                break;
            }
        }
    }
    
    advanceToNextPhase(nextPhase) {
        // Frontend advances UI to next phase
        // Backend is already in the correct state
        this.gameUI.transitionToPhase(nextPhase);
    }
}

// CRITICAL IMPLEMENTATION RULE:
// Backend NEVER waits for display timing
// Frontend ALWAYS controls display duration
// Backend provides display metadata only
```

### Performance Improvements

**Before (Polling)**:
- **CPU**: 10 polls/second continuously = 600 polls/minute
- **Latency**: 100ms polling + 100ms transition = 200ms total
- **Memory**: Growing task references, no cleanup
- **Race Conditions**: High risk due to timing dependencies

**After (Event-Driven)**:
- **CPU**: Only when events occur = ~95% reduction
- **Latency**: <10ms immediate processing = 95% reduction  
- **Memory**: Managed task lifecycle, automatic cleanup
- **Race Conditions**: Eliminated via async locks and serialization

## ðŸŽ¨ Phase 2.3: Display vs Logic Separation Implementation

### Current Problem: Logic Coupled to Display Timing

**Problematic Pattern in ScoringState** (Race Conditions Analysis):
```python
# Current: Logic waits for display timing (lines from RACE_CONDITIONS.md)
ðŸ” SCORING_TRANSITION_DEBUG: Checking transition conditions:
  ðŸ“Š scores_calculated: True
  â° display_delay_complete: False  â† LOGIC WAITS FOR DISPLAY
  ðŸ game_complete: False
ðŸ” SCORING_TRANSITION_DEBUG: Not ready - display delay not complete
... (repeated ~15 times) ...
â° SCORING_DELAY_DEBUG: 7-second delay complete
```

**Issues**:
- **Logic Blocking**: Game state waits for UI timing
- **Artificial Delays**: State transitions artificially slowed
- **Race Conditions**: Timer completion vs polling detection
- **Poor UX**: Frontend receives delayed updates

### Target: Complete Logic/Display Separation

**Separation Architecture Pattern**:
```python
class GamePhaseManager:
    """Manages both logic and display phases independently"""
    
    def __init__(self, state_machine: GameStateMachine):
        self.state_machine = state_machine
        self.logic_phase = None      # Current game logic state
        self.display_phase = None    # Current display state (can differ)
        self.display_timers = {}     # Managed display timers
        
    async def process_logic_event(self, event: GameEvent):
        """Process logic immediately - NO DISPLAY DELAYS"""
        
        # Process logic event immediately
        result = await self.state_machine.current_state.process_event(event)
        
        if result.triggers_transition:
            # Logic transition happens immediately
            await self._immediate_logic_transition(result.target_state, result.reason)
            
            # Display phase starts in parallel (if needed)
            if self._needs_display_phase(result.target_state):
                await self._start_parallel_display_phase(result.target_state)
    
    async def _immediate_logic_transition(self, target_state: GamePhase, reason: str):
        """Logic transition with zero delays"""
        
        # Update logic phase immediately
        old_logic_phase = self.logic_phase
        self.logic_phase = target_state
        
        # Transition state machine immediately
        await self.state_machine._atomic_transition_to(target_state, reason)
        
        # Broadcast immediate logic update to frontend
        await self._broadcast_logic_change(old_logic_phase, target_state, reason)
    
    async def _start_parallel_display_phase(self, logic_phase: GamePhase):
        """Start display timing in parallel - NO LOGIC IMPACT"""
        
        display_config = self._get_display_config(logic_phase)
        if not display_config:
            return
        
        # Cancel any existing display timer for this phase
        await self._cancel_display_timer(logic_phase)
        
        # Start new display timer (parallel to logic)
        display_timer = asyncio.create_task(
            self._display_timing_process(logic_phase, display_config)
        )
        self.display_timers[logic_phase] = display_timer
        
        # Immediate frontend notification about display phase
        await self._broadcast_display_phase_start(logic_phase, display_config)
```

### Display Timing Without Blocking Logic

**Non-Blocking Display Pattern**:
```python
class DisplayTimingManager:
    """Handles all display timing separate from game logic"""
    
    def __init__(self, phase_manager: GamePhaseManager):
        self.phase_manager = phase_manager
        self.active_displays = {}
        
    async def start_display_timing(self, logic_phase: GamePhase, config: DisplayConfig):
        """Start display timing that doesn't block logic"""
        
        display_id = f"{logic_phase.value}_{time.time()}"
        
        # Create display state
        display_state = DisplayState(
            logic_phase=logic_phase,
            duration=config.duration,
            auto_advance=config.auto_advance,
            can_skip=config.can_skip
        )
        
        self.active_displays[display_id] = display_state
        
        # Start display timer (non-blocking)
        timer_task = asyncio.create_task(
            self._run_display_timer(display_id, display_state)
        )
        
        # Register for cleanup
        timer_task.add_done_callback(
            lambda t: self.active_displays.pop(display_id, None)
        )
        
        return display_id
    
    async def _run_display_timer(self, display_id: str, state: DisplayState):
        """Run display timer without affecting game logic"""
        
        try:
            # Wait for display duration
            await asyncio.sleep(state.duration)
            
            # Notify frontend that display can advance
            await self._notify_display_complete(display_id, state)
            
            # If auto-advance enabled, trigger frontend update
            if state.auto_advance:
                await self._trigger_auto_advance(display_id, state)
                
        except asyncio.CancelledError:
            # Display was cancelled (e.g., user skipped, state changed)
            await self._notify_display_cancelled(display_id, state)
        
        except Exception as e:
            logger.error(f"Display timer error: {e}")
            await self._notify_display_error(display_id, state, str(e))
    
    async def skip_display(self, display_id: str) -> bool:
        """Allow user to skip display timing"""
        
        display_state = self.active_displays.get(display_id)
        if not display_state or not display_state.can_skip:
            return False
        
        # Cancel display timer
        if display_id in self.active_displays:
            timer_task = self.active_displays[display_id].timer_task
            if timer_task and not timer_task.done():
                timer_task.cancel()
        
        # Immediate display completion
        await self._notify_display_complete(display_id, display_state)
        return True
```

### Frontend Sync for Immediate State Updates

**Dual Update Pattern** (Logic + Display):
```python
class FrontendSyncManager:
    """Manages frontend synchronization for both logic and display"""
    
    async def broadcast_logic_update(self, event_data: Dict):
        """Immediate broadcast of logic state changes"""
        
        # Add timing metadata
        event_data.update({
            "update_type": "logic",
            "immediate": True,
            "timestamp": time.time(),
            "requires_display": self._requires_display_phase(event_data)
        })
        
        # Immediate broadcast to all clients
        await self.state_machine.broadcast_event("logic_update", event_data)
    
    async def broadcast_display_update(self, display_event: Dict):
        """Broadcast display timing events (non-critical)"""
        
        display_event.update({
            "update_type": "display",
            "immediate": False,
            "optional": True  # Frontend can ignore if busy
        })
        
        # Non-blocking broadcast
        await self.state_machine.broadcast_event("display_update", display_event)
    
    async def broadcast_dual_update(self, logic_data: Dict, display_data: Dict):
        """Broadcast both logic and display updates together"""
        
        combined_event = {
            "update_type": "dual",
            "logic": {**logic_data, "immediate": True},
            "display": {**display_data, "immediate": False},
            "timestamp": time.time()
        }
        
        await self.state_machine.broadcast_event("phase_transition", combined_event)

# Frontend message handling pattern
class FrontendEventHandler:
    def handle_logic_update(self, event_data: Dict):
        """Handle immediate logic updates"""
        # Update game state immediately
        self.update_game_state(event_data["logic"])
        
        # Start display phase if needed
        if event_data.get("requires_display"):
            self.start_display_phase(event_data["display"])
    
    def handle_display_update(self, event_data: Dict):
        """Handle display timing updates (optional)"""
        # Update UI timing only, don't change game logic
        if self.is_ready_for_display_updates():
            self.update_display_timing(event_data)
```

### User Experience Preservation Patterns

**Smooth Transition UX**:
```python
class UserExperienceManager:
    """Preserves game flow feel while implementing immediate logic"""
    
    def __init__(self, display_manager: DisplayTimingManager):
        self.display_manager = display_manager
        self.user_preferences = {}
        
    async def handle_turn_completion(self, turn_data: Dict):
        """Smooth turn completion experience"""
        
        # 1. Logic processes immediately
        await self._process_turn_completion_logic(turn_data)
        
        # 2. Start turn results display (parallel)
        display_id = await self.display_manager.start_display_timing(
            GamePhase.TURN_RESULTS,
            DisplayConfig(
                duration=7.0,
                auto_advance=True,
                can_skip=True,
                animations=["piece_transfer", "score_update"]
            )
        )
        
        # 3. Provide user control options
        await self._offer_display_controls(display_id, turn_data)
    
    async def handle_scoring_completion(self, scores: Dict):
        """Smooth scoring experience"""
        
        # Logic: Scores calculated and round advanced immediately
        await self._process_scoring_logic(scores)
        
        # Display: Show scoring breakdown with timing
        display_id = await self.display_manager.start_display_timing(
            GamePhase.SCORING_DISPLAY,
            DisplayConfig(
                duration=7.0,
                auto_advance=True,
                can_skip=True,
                animations=["score_calculation", "leaderboard_update"]
            )
        )
        
        # Allow manual advance
        await self._enable_manual_advance(display_id)
    
    async def _offer_display_controls(self, display_id: str, context: Dict):
        """Give users control over display timing"""
        
        controls = {
            "can_skip": True,
            "can_pause": True,
            "can_replay": True,
            "speed_options": ["0.5x", "1x", "2x", "instant"]
        }
        
        await self.state_machine.broadcast_event("display_controls", {
            "display_id": display_id,
            "controls": controls,
            "context": context
        })
    
    def get_display_preferences(self, player_name: str) -> Dict:
        """Get player's display timing preferences"""
        return self.user_preferences.get(player_name, {
            "auto_advance": True,
            "display_speed": 1.0,
            "skip_animations": False,
            "show_detailed_results": True
        })

# Example: Turn completion with preserved UX
async def process_turn_completion_with_ux(self, turn_data: Dict):
    """Turn completion that feels natural but has immediate logic"""
    
    # 1. IMMEDIATE: Process turn winner and piece transfer
    winner = await self._determine_turn_winner(turn_data["plays"])
    await self._transfer_pieces_to_winner(winner, turn_data["pieces"])
    await self._update_game_state_immediately()
    
    # 2. IMMEDIATE: Broadcast logic update to frontend
    await self.broadcast_event("turn_completed", {
        "winner": winner,
        "pieces_transferred": len(turn_data["pieces"]),
        "next_phase": "scoring" if self._all_hands_empty() else "next_turn",
        "immediate_update": True
    })
    
    # 3. PARALLEL: Start turn results display for UX
    ux_manager = UserExperienceManager(self.display_manager)
    await ux_manager.handle_turn_completion(turn_data)
    
    # 4. IMMEDIATE: Continue to next phase logic
    if self._all_hands_empty():
        await self.trigger_immediate_transition(GamePhase.SCORING)
    else:
        await self._start_next_turn_immediately()
```

### Implementation Priority

**Critical Patterns (Phase 3 Implementation)**:
1. **GamePhaseManager**: Separate logic and display phases
2. **DisplayTimingManager**: Non-blocking display timing  
3. **FrontendSyncManager**: Dual update broadcasts
4. **Immediate Logic Flow**: Zero-delay state transitions

**UX Enhancement Patterns (Phase 4 Implementation)**:
1. **UserExperienceManager**: Smooth transition UX
2. **Display Controls**: User timing preferences
3. **Animation Coordination**: Smooth visual transitions
4. **Progressive Enhancement**: Graceful degradation

---

**Phase 2.1**: âœ… COMPLETED - All event types defined  
**Phase 2.2**: âœ… COMPLETED - Immediate transition architecture designed  
**Phase 2.3**: âœ… COMPLETED - Display vs logic separation planned  
**Phase 2**: âœ… FULLY COMPLETED - Event-driven design complete  
**Next**: Phase 3.1 - Convert State Machine Core