import {
  Align,
  BoxSizing,
  DebugRenderer,
  Direction,
  Display,
  Edge,
  FlexDirection,
  Gutter,
  Justify,
  Overflow,
  PositionType,
  Wrap,
  loadYoga
} from "./chunk-YLHYOG3V.js";
import {
  AbstractText,
  NineSliceSprite,
  TilingSprite
} from "./chunk-RLYHC7S5.js";
import "./chunk-TBMXDUDW.js";
import "./chunk-FDYIZHX5.js";
import "./chunk-VG2V336I.js";
import "./chunk-BTVP4HHG.js";
import "./chunk-LFF6H75X.js";
import "./chunk-C4XUKHUI.js";
import {
  Bounds,
  Container,
  ExtensionType,
  Point,
  ViewContainer,
  extensions
} from "./chunk-RKLCK3GT.js";
import "./chunk-5WRI5ZAA.js";

// node_modules/@pixi/layout/dist/yoga.mjs
var yoga;
function getYoga() {
  return yoga;
}
function setYoga(newYoga) {
  yoga = newYoga;
}

// node_modules/@pixi/layout/dist/core/utils/getNumberFromStyle.mjs
function getNumberFromStyle(value, size) {
  if (!value) return 0;
  if (typeof value === "number") {
    return value;
  } else if (typeof value === "string" && value.endsWith("%")) {
    size ?? (size = 1);
    return size * (parseFloat(value) / 100);
  } else if (!Number.isNaN(parseFloat(value))) {
    return parseFloat(value);
  }
  return 0;
}
function getTypeFromStyle(value) {
  if (typeof value === "number") return "number";
  if (value.endsWith("%")) return "percentage";
  if (Number.isNaN(parseInt(value, 10))) return "keyword";
  return "number";
}

// node_modules/@pixi/layout/dist/core/mixins/utils/position/calculateWithDoubleValue.mjs
function calculateCenterPosition(dimension, computedLayout, visualBounds) {
  return (computedLayout[dimension] - visualBounds[dimension]) / 2;
}
function calculateNonKeywordPosition(value, valueType, dimension, computedLayout, visualBounds) {
  const multiple = valueType === "percentage" ? computedLayout[dimension] - visualBounds[dimension] : 1;
  return getNumberFromStyle(value) * multiple;
}
function calculateWithDoubleValue(tokens, computedLayout, visualBounds) {
  const [first, second] = tokens;
  const firstType = getTypeFromStyle(first);
  const secondType = getTypeFromStyle(second);
  const result = { x: void 0, y: void 0 };
  switch (first) {
    case "top":
      result.y = 0;
      break;
    case "bottom":
      result.y = computedLayout.height - visualBounds.height;
      break;
    case "center":
      if (second === "left" || second === "right") {
        result.y = calculateCenterPosition("height", computedLayout, visualBounds);
      } else {
        result.x = calculateCenterPosition("width", computedLayout, visualBounds);
      }
      break;
    case "left":
      result.x = 0;
      break;
    case "right":
      result.x = computedLayout.width - visualBounds.width;
      break;
    default: {
      const dimension = second === "top" || second === "bottom" || secondType !== "keyword" ? "width" : "height";
      const target = dimension === "width" ? "x" : "y";
      result[target] = calculateNonKeywordPosition(first, firstType, dimension, computedLayout, visualBounds);
    }
  }
  switch (second) {
    case "top":
      result.y = 0;
      break;
    case "bottom":
      result.y = computedLayout.height - visualBounds.height;
      break;
    case "center":
      if (result.y === void 0) {
        result.y = calculateCenterPosition("height", computedLayout, visualBounds);
      } else {
        result.x = calculateCenterPosition("width", computedLayout, visualBounds);
      }
      break;
    case "left":
      result.x = 0;
      break;
    case "right":
      result.x = computedLayout.width - visualBounds.width;
      break;
    default: {
      const target = result.y === void 0 ? "y" : "x";
      const dimension = target === "y" ? "height" : "width";
      result[target] = calculateNonKeywordPosition(second, secondType, dimension, computedLayout, visualBounds);
    }
  }
  return result;
}

// node_modules/@pixi/layout/dist/core/mixins/utils/position/calculateWithQuadValue.mjs
function calculateAxisOffset(keyword, value, type, bounds) {
  const isNegativeOffset = keyword === "right" || keyword === "bottom";
  const offset = type === "percentage" ? value * bounds : value;
  return isNegativeOffset ? -offset : offset;
}
function calculateWithQuadValue(tokens, computedLayout, visualBounds) {
  const [first, second, third, fourth] = tokens;
  const firstType = getTypeFromStyle(first);
  const secondType = getTypeFromStyle(second);
  const thirdType = getTypeFromStyle(third);
  const fourthType = getTypeFromStyle(fourth);
  if (secondType === "keyword" || fourthType === "keyword") {
    throw new Error("Invalid objectPosition value: second and fourth values must be numbers or percentages");
  }
  if (firstType !== "keyword" || thirdType !== "keyword") {
    throw new Error("Invalid objectPosition value: first and third values must be keywords");
  }
  const basePosition = calculateWithDoubleValue([first, third], computedLayout, visualBounds);
  const result = { ...basePosition };
  const secondValue = getNumberFromStyle(second);
  const fourthValue = getNumberFromStyle(fourth);
  if (first === "left" || first === "right") {
    result.x = basePosition.x + calculateAxisOffset(first, secondValue, secondType, visualBounds.width);
  } else if (first === "top" || first === "bottom") {
    result.y = basePosition.y + calculateAxisOffset(first, secondValue, secondType, visualBounds.height);
  }
  if (third === "left" || third === "right") {
    result.x = basePosition.x + calculateAxisOffset(third, fourthValue, fourthType, visualBounds.width);
  } else if (third === "top" || third === "bottom") {
    result.y = basePosition.y + calculateAxisOffset(third, fourthValue, fourthType, visualBounds.height);
  }
  return result;
}

// node_modules/@pixi/layout/dist/core/mixins/utils/position/calculateWithSingleValue.mjs
function calculateWithSingleValue(tokens, computedLayout, visualBounds) {
  const keyword = tokens[0];
  const result = { x: void 0, y: void 0 };
  switch (keyword) {
    case "top":
      result.y = 0;
      result.x = (computedLayout.width - visualBounds.width) / 2;
      break;
    case "bottom":
      result.y = computedLayout.height - visualBounds.height;
      result.x = (computedLayout.width - visualBounds.width) / 2;
      break;
    case "left":
      result.x = 0;
      result.y = (computedLayout.height - visualBounds.height) / 2;
      break;
    case "right":
      result.x = computedLayout.width - visualBounds.width;
      result.y = (computedLayout.height - visualBounds.height) / 2;
      break;
    case "center":
      result.x = (computedLayout.width - visualBounds.width) / 2;
      result.y = (computedLayout.height - visualBounds.height) / 2;
      break;
    default: {
      const isPercentage = getTypeFromStyle(keyword) === "percentage";
      const multiple = isPercentage ? computedLayout.width - visualBounds.width : 1;
      result.x = getNumberFromStyle(keyword) * multiple;
      result.y = (computedLayout.height - visualBounds.height) / 2;
    }
  }
  return result;
}

// node_modules/@pixi/layout/dist/core/mixins/utils/calculatePositionSpecifier.mjs
function calculatePositionSpecifier(value, computedLayout, visualBounds) {
  if (!value) return { x: 0, y: 0 };
  const tokens = typeof value === "string" ? value.split(" ") : [value];
  switch (tokens.length) {
    case 1:
      return calculateWithSingleValue(tokens, computedLayout, visualBounds);
    case 2:
      return calculateWithDoubleValue(tokens, computedLayout, visualBounds);
    case 4:
      return calculateWithQuadValue(tokens, computedLayout, visualBounds);
    default:
      throw new Error("Invalid objectPosition value: must have 1, 2, or 4 values");
  }
}

// node_modules/@pixi/layout/dist/core/utils/getPixiSize.mjs
var tempBounds = new Bounds();
var temp = { width: 0, height: 0 };
function getPixiSize(layout) {
  const bounds = layout.target.getLocalBounds(tempBounds);
  const scale = layout.target.scale;
  temp.width = Math.abs(bounds.width * scale.x);
  temp.height = Math.abs(bounds.height * scale.y);
  return temp;
}

// node_modules/@pixi/layout/dist/core/utils/nearlyEqual.mjs
function nearlyEqual(a, b, EPSILON = 0.49) {
  return Math.abs(a - b) < EPSILON;
}

// node_modules/@pixi/layout/dist/core/utils/throttle.mjs
var throttleMap = /* @__PURE__ */ new Map();
function throttle(fun, delay = 100, scope) {
  if (!throttleMap.has(fun)) {
    let timerId = null;
    const throttledFunction = (...args) => {
      throttleMap.get(fun).args = args;
      if (timerId) return;
      const callFun = () => {
        timerId = null;
        const latestArgs = throttleMap.get(fun).args;
        {
          fun(...latestArgs);
        }
      };
      if (delay === 0) {
        callFun();
      } else {
        timerId = setTimeout(callFun, delay);
      }
    };
    throttleMap.set(fun, { throttledFunction, args: null });
  }
  return throttleMap.get(fun).throttledFunction;
}

// node_modules/@pixi/layout/dist/core/LayoutSystem.mjs
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var LayoutSystem = class {
  constructor() {
    __publicField(this, "autoUpdate", true);
    __publicField(this, "_debugEnabled", false);
    __publicField(this, "_debugRenderer", null);
    __publicField(this, "_throttledUpdateSize");
    __publicField(this, "_throttle", 100);
    __publicField(this, "_modificationCount", 50);
  }
  /**
   * Initializes the layout system by loading the Yoga library asynchronously
   * @returns A promise that resolves when the system is ready
   */
  async init(options) {
    setYoga(await loadYoga());
    const { layout } = options ?? {};
    const { autoUpdate, enableDebug, throttle: throttle$1, debugModificationCount } = layout ?? {};
    if (enableDebug) {
      void this.enableDebug(true);
    }
    if (autoUpdate !== void 0) {
      this.autoUpdate = autoUpdate;
    }
    this._throttle = throttle$1 ?? this._throttle;
    this._throttledUpdateSize = throttle((container) => this._updateSize(container), this._throttle);
    this._modificationCount = debugModificationCount ?? this._modificationCount;
  }
  /**
   * Toggles the debug mode for the layout system
   * @param value - Whether to enable or disable debug mode
   */
  async enableDebug(value = !this._debugEnabled) {
    this._debugEnabled = value;
    if (!this._debugRenderer) {
      const res = await import("./DebugRenderer-Y7IGNJ2V.js");
      this._debugRenderer = new res.DebugRenderer();
    }
    if (!this._debugEnabled) {
      this._debugRenderer.reset();
    }
  }
  /**
   * Updates the layout of the container and its children
   * @param container - The container to update the layout for
   */
  update(container) {
    if (this._debugEnabled && this._debugRenderer) {
      this._debugRenderer.reset();
      container.addChild(this._debugRenderer.holder);
    }
    this._throttledUpdateSize(container);
    this.updateLayout(container);
  }
  prerender({ container }) {
    if (this.autoUpdate) {
      this.update(container);
    }
  }
  /**
   * Updates the size of the yoga nodes for the containers that use pixi size
   * @param container - The container to update the size for
   */
  _updateSize(container) {
    const layout = container._layout;
    if (layout) {
      const layoutStyles = layout.style;
      if (layoutStyles.width === "intrinsic" || layoutStyles.height === "intrinsic") {
        const size = getPixiSize(layout);
        if (layoutStyles.width === "intrinsic") {
          const currentWidth = layout.yoga.getWidth().value;
          if (!nearlyEqual(currentWidth, size.width)) {
            layout.yoga.setWidth(size.width);
            layout.invalidateRoot();
          }
        }
        if (layoutStyles.height === "intrinsic") {
          const currentHeight = layout.yoga.getHeight().value;
          if (!nearlyEqual(currentHeight, size.height)) {
            layout.yoga.setHeight(size.height);
            layout.invalidateRoot();
          }
        }
      }
      if (!container.visible) {
        layout._onChildRemoved();
        return;
      }
    }
    for (let i = 0; i < container.children.length; i++) {
      this._updateSize(container.children[i]);
    }
  }
  /**
   * Updates the layout of the container and its children
   * @param container - The container to update the layout for
   */
  updateLayout(container) {
    var _a, _b, _c, _d;
    const layout = container._layout;
    if (!container.visible) {
      return;
    }
    if (layout) {
      const yogaNode = layout.yoga;
      const layoutStyles = layout.style;
      const isOverflowContainer = (_a = container.parent) == null ? void 0 : _a.isOverflowContainer;
      const hasParentLayout = (_b = container.parent) == null ? void 0 : _b._layout;
      if (!hasParentLayout && !isOverflowContainer) {
        if (layout._isDirty) {
          layout._isDirty = false;
          yogaNode.calculateLayout(
            layoutStyles.width,
            // TODO: if this is not a number, it will not work
            layoutStyles.height,
            yogaNode.getDirection() ?? Direction.LTR
          );
        }
      }
      if (yogaNode.hasNewLayout() || layout._forceUpdate) {
        yogaNode.markLayoutSeen();
        layout._forceUpdate = false;
        layout._computedLayout = yogaNode.getComputedLayout();
        const res = calculatePositionSpecifier(layoutStyles.transformOrigin, layout._computedLayout, {
          width: 0,
          height: 0
        });
        layout._computedPixiLayout = {
          ...container.computeLayoutData(layout._computedLayout),
          originX: res.x,
          originY: res.y
        };
        container.emit("layout", layout);
        (_c = container.onLayout) == null ? void 0 : _c.call(container, layout);
        container._onUpdate();
      }
      if (this._debugEnabled) {
        if (layout._styles.custom.debug || layout._modificationCount > this._modificationCount && layout._styles.custom.debugHeat !== false) {
          (_d = this._debugRenderer) == null ? void 0 : _d.render(layout);
        }
      }
    }
    for (let i = 0; i < container.children.length; i++) {
      this.updateLayout(container.children[i]);
    }
  }
  /**
   * @ignore
   */
  destroy() {
    if (!this._debugEnabled && this._debugRenderer) {
      this._debugRenderer.destroy();
    }
  }
};
__publicField(LayoutSystem, "extension", {
  type: [ExtensionType.WebGLSystem, ExtensionType.WebGPUSystem],
  name: "layout"
});

// node_modules/@pixi/layout/dist/core/style/applyStyle.mjs
var ALIGN_CONTENT_MAP = {
  "flex-start": Align.FlexStart,
  "flex-end": Align.FlexEnd,
  center: Align.Center,
  stretch: Align.Stretch,
  "space-between": Align.SpaceBetween,
  "space-around": Align.SpaceAround,
  "space-evenly": Align.SpaceEvenly
};
var ALIGN_ITEMS_MAP = {
  "flex-start": Align.FlexStart,
  "flex-end": Align.FlexEnd,
  center: Align.Center,
  stretch: Align.Stretch,
  baseline: Align.Baseline
};
var BOX_SIZING_MAP = {
  "border-box": BoxSizing.BorderBox,
  "content-box": BoxSizing.ContentBox
};
var DIRECTION_MAP = {
  ltr: Direction.LTR,
  rtl: Direction.RTL
};
var DISPLAY_MAP = {
  none: Display.None,
  flex: Display.Flex,
  contents: Display.Contents
};
var FLEX_DIRECTION_MAP = {
  row: FlexDirection.Row,
  column: FlexDirection.Column,
  "row-reverse": FlexDirection.RowReverse,
  "column-reverse": FlexDirection.ColumnReverse
};
var FLEX_WRAP_MAP = {
  wrap: Wrap.Wrap,
  nowrap: Wrap.NoWrap,
  "wrap-reverse": Wrap.WrapReverse
};
var JUSTIFY_CONTENT_MAP = {
  "flex-start": Justify.FlexStart,
  "flex-end": Justify.FlexEnd,
  center: Justify.Center,
  "space-between": Justify.SpaceBetween,
  "space-around": Justify.SpaceAround,
  "space-evenly": Justify.SpaceEvenly
};
var OVERFLOW_MAP = {
  visible: Overflow.Visible,
  hidden: Overflow.Hidden,
  scroll: Overflow.Scroll
};
var POSITION_MAP = {
  absolute: PositionType.Absolute,
  relative: PositionType.Relative,
  static: PositionType.Static
};
var styleSetters = {
  alignContent: (node, value) => node.setAlignContent(alignContent(value)),
  alignItems: (node, value) => node.setAlignItems(alignItems(value)),
  alignSelf: (node, value) => node.setAlignSelf(alignItems(value)),
  aspectRatio: (node, value) => node.setAspectRatio(value),
  borderBottomWidth: (node, value) => node.setBorder(Edge.Bottom, value),
  borderEndWidth: (node, value) => node.setBorder(Edge.End, value),
  borderLeftWidth: (node, value) => node.setBorder(Edge.Left, value),
  borderRightWidth: (node, value) => node.setBorder(Edge.Right, value),
  borderStartWidth: (node, value) => node.setBorder(Edge.Start, value),
  borderTopWidth: (node, value) => node.setBorder(Edge.Top, value),
  borderWidth: (node, value) => node.setBorder(Edge.All, value),
  borderInlineWidth: (node, value) => node.setBorder(Edge.Horizontal, value),
  borderBlockWidth: (node, value) => node.setBorder(Edge.Vertical, value),
  bottom: (node, value) => node.setPosition(Edge.Bottom, value),
  boxSizing: (node, value) => node.setBoxSizing(boxSizing(value)),
  direction: (node, value) => node.setDirection(direction(value)),
  display: (node, value) => node.setDisplay(display(value)),
  end: (node, value) => node.setPosition(Edge.End, value),
  flex: (node, value) => node.setFlex(value),
  flexBasis: (node, value) => node.setFlexBasis(value),
  flexDirection: (node, value) => node.setFlexDirection(flexDirection(value)),
  rowGap: (node, value) => node.setGap(Gutter.Row, value),
  gap: (node, value) => node.setGap(Gutter.All, value),
  columnGap: (node, value) => node.setGap(Gutter.Column, value),
  flexGrow: (node, value) => node.setFlexGrow(value),
  flexShrink: (node, value) => node.setFlexShrink(value),
  flexWrap: (node, value) => node.setFlexWrap(flexWrap(value)),
  height: (node, value) => node.setHeight(value),
  justifyContent: (node, value) => node.setJustifyContent(justifyContent(value)),
  left: (node, value) => node.setPosition(Edge.Left, value),
  margin: (node, value) => node.setMargin(Edge.All, value),
  marginBottom: (node, value) => node.setMargin(Edge.Bottom, value),
  marginEnd: (node, value) => node.setMargin(Edge.End, value),
  marginLeft: (node, value) => node.setMargin(Edge.Left, value),
  marginRight: (node, value) => node.setMargin(Edge.Right, value),
  marginStart: (node, value) => node.setMargin(Edge.Start, value),
  marginTop: (node, value) => node.setMargin(Edge.Top, value),
  marginInline: (node, value) => node.setMargin(Edge.Horizontal, value),
  marginBlock: (node, value) => node.setMargin(Edge.Vertical, value),
  maxHeight: (node, value) => node.setMaxHeight(value),
  maxWidth: (node, value) => node.setMaxWidth(value),
  minHeight: (node, value) => node.setMinHeight(value),
  minWidth: (node, value) => node.setMinWidth(value),
  overflow: (node, value) => node.setOverflow(overflow(value)),
  padding: (node, value) => node.setPadding(Edge.All, value),
  paddingBottom: (node, value) => node.setPadding(Edge.Bottom, value),
  paddingEnd: (node, value) => node.setPadding(Edge.End, value),
  paddingLeft: (node, value) => node.setPadding(Edge.Left, value),
  paddingRight: (node, value) => node.setPadding(Edge.Right, value),
  paddingStart: (node, value) => node.setPadding(Edge.Start, value),
  paddingTop: (node, value) => node.setPadding(Edge.Top, value),
  paddingInline: (node, value) => node.setPadding(Edge.Horizontal, value),
  paddingBlock: (node, value) => node.setPadding(Edge.Vertical, value),
  position: (node, value) => node.setPositionType(position(value)),
  right: (node, value) => node.setPosition(Edge.Right, value),
  start: (node, value) => node.setPosition(Edge.Start, value),
  top: (node, value) => node.setPosition(Edge.Top, value),
  insetInline: (node, value) => node.setPosition(Edge.Horizontal, value),
  insetBlock: (node, value) => node.setPosition(Edge.Vertical, value),
  inset: (node, value) => node.setPosition(Edge.All, value),
  width: (node, value) => node.setWidth(value)
};
function alignContent(str) {
  if (str in ALIGN_CONTENT_MAP) return ALIGN_CONTENT_MAP[str];
  throw new Error(`"${str}" is not a valid value for alignContent`);
}
function alignItems(str) {
  if (str in ALIGN_ITEMS_MAP) return ALIGN_ITEMS_MAP[str];
  throw new Error(`"${str}" is not a valid value for alignItems`);
}
function boxSizing(str) {
  if (str in BOX_SIZING_MAP) return BOX_SIZING_MAP[str];
  throw new Error(`"${str}" is not a valid value for boxSizing`);
}
function direction(str) {
  if (str in DIRECTION_MAP) return DIRECTION_MAP[str];
  throw new Error(`"${str}" is not a valid value for direction`);
}
function display(str) {
  if (str in DISPLAY_MAP) return DISPLAY_MAP[str];
  throw new Error(`"${str}" is not a valid value for display`);
}
function flexDirection(str) {
  if (str in FLEX_DIRECTION_MAP) return FLEX_DIRECTION_MAP[str];
  throw new Error(`"${str}" is not a valid value for flexDirection`);
}
function flexWrap(str) {
  if (str in FLEX_WRAP_MAP) return FLEX_WRAP_MAP[str];
  throw new Error(`"${str}" is not a valid value for flexWrap`);
}
function justifyContent(str) {
  if (str in JUSTIFY_CONTENT_MAP) return JUSTIFY_CONTENT_MAP[str];
  throw new Error(`"${str}" is not a valid value for justifyContent`);
}
function overflow(str) {
  if (str in OVERFLOW_MAP) return OVERFLOW_MAP[str];
  throw new Error(`"${str}" is not a valid value for overflow`);
}
function position(str) {
  if (str in POSITION_MAP) return POSITION_MAP[str];
  throw new Error(`"${str}" is not a valid value for position`);
}
function applyStyle(node, style = {}) {
  for (const [key, value] of Object.entries(style)) {
    try {
      const setter = styleSetters[key];
      if (setter) {
        setter(node, value);
      }
    } catch (_e) {
    }
  }
  if (style.width !== void 0) {
    const widthValue = style.left !== void 0 && style.right !== void 0 ? "auto" : style.width;
    node.setWidth(widthValue);
  }
  if (style.height !== void 0) {
    const heightValue = style.top !== void 0 && style.bottom !== void 0 ? "auto" : style.height;
    node.setHeight(heightValue);
  }
}

// node_modules/@pixi/layout/dist/core/style/formatStyles.mjs
function formatStyles(layout, style) {
  const currentStyles = layout._styles;
  let customStyles = { ...currentStyles.custom, ...style };
  const defaultStyle = {
    ...Layout.defaultStyle.shared,
    ...layout.target instanceof ViewContainer || customStyles.isLeaf || Layout.defaultStyle.shared.isLeaf ? Layout.defaultStyle.leaf : Layout.defaultStyle.container
  };
  customStyles = { ...defaultStyle, ...customStyles };
  const yogaStyles = { ...customStyles };
  const widthIntrinsic = customStyles.width === "intrinsic";
  const heightIntrinsic = customStyles.height === "intrinsic";
  if (widthIntrinsic || heightIntrinsic) {
    const { width, height } = getPixiSize(layout);
    if (widthIntrinsic) {
      yogaStyles.width = width;
    }
    if (heightIntrinsic) {
      yogaStyles.height = height;
    }
  }
  return { custom: customStyles, yoga: yogaStyles };
}

// node_modules/@pixi/layout/dist/core/utils/sort-children.mjs
function onChildAdded(layout, pixiParent) {
  var _a;
  let parentLayout = pixiParent.layout;
  let yogaIndex = -1;
  if (!parentLayout && pixiParent.isOverflowContainer) {
    parentLayout = (_a = pixiParent.parent) == null ? void 0 : _a.layout;
    yogaIndex = pixiParent.children.indexOf(layout.target);
    pixiParent = pixiParent.parent;
  }
  if (parentLayout) {
    const yogaParent = layout.yoga.getParent();
    if (yogaParent) {
      yogaParent.removeChild(layout.yoga);
    }
    if (pixiParent.children.indexOf(layout.target) === pixiParent.children.length - 1 && yogaIndex === -1) {
      parentLayout.yoga.insertChild(layout.yoga, parentLayout.yoga.getChildCount());
      return;
    }
    for (let i = 0; i < pixiParent.children.length; i++) {
      const child = pixiParent.children[i];
      if (child.layout && child.visible) {
        yogaIndex++;
      }
      if (child === layout.target) {
        break;
      }
    }
    parentLayout.yoga.insertChild(layout.yoga, yogaIndex);
  }
}
function onChildRemoved(layout) {
  const yogaParent = layout.yoga.getParent();
  yogaParent && yogaParent.removeChild(layout.yoga);
}

// node_modules/@pixi/layout/dist/core/Layout.mjs
var __defProp2 = Object.defineProperty;
var __defNormalProp2 = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField2 = (obj, key, value) => __defNormalProp2(obj, typeof key !== "symbol" ? key + "" : key, value);
var Layout = class {
  constructor({ target }) {
    __publicField2(this, "yoga");
    __publicField2(this, "target");
    __publicField2(this, "_isDirty", false);
    __publicField2(this, "_computedPixiLayout", {
      /** The left value of the view */
      x: 0,
      /** The top value of the view */
      y: 0,
      /** The offset x value of the view within its box */
      offsetX: 0,
      /** The offset y value of the view within its box */
      offsetY: 0,
      /** The scale x value of the view within its box */
      scaleX: 1,
      /** The scale y value of the view within its box */
      scaleY: 1,
      /** The x origin of the view */
      originX: 0,
      /** The y origin of the view */
      originY: 0
    });
    __publicField2(this, "_computedLayout", {
      /** The left value of the view */
      left: 0,
      /** The right value of the view */
      right: 0,
      /** The top value of the view */
      top: 0,
      /** The bottom value of the view */
      bottom: 0,
      /** The width of the view */
      width: 0,
      /** The height of the view */
      height: 0
    });
    __publicField2(this, "_styles", {
      custom: {},
      yoga: {}
    });
    __publicField2(this, "_modificationCount", 0);
    __publicField2(this, "_forceUpdate", false);
    __publicField2(this, "hasParent", false);
    __publicField2(this, "_trackedStyleKeys", [
      "borderRadius",
      "borderColor",
      "backgroundColor",
      "objectFit",
      "objectPosition",
      "transformOrigin",
      "isLeaf"
    ]);
    this.target = target;
    this.yoga = getYoga().Node.create();
    target.on("added", this._onChildAdded, this);
    target.on("removed", this._onChildRemoved, this);
    target.on("destroyed", this.destroy, this);
  }
  /** Returns the layout style */
  get style() {
    return this._styles.custom;
  }
  /** Returns the computed layout of the yoga node */
  get computedLayout() {
    return this._computedLayout;
  }
  /** Returns the computed layout of the pixi node */
  get computedPixiLayout() {
    return this._computedPixiLayout;
  }
  /**
   * Returns the true x position of the target.
   *
   * When an element is in layout, the x/y position is an offset from where it is laid out.
   * This is the true x position of the element in the parent container.
   */
  get realX() {
    return this.target.localTransform.tx;
  }
  /**
   * Returns the true y position of the target.
   *
   * When an element is in layout, the x/y position is an offset from where it is laid out.
   * This is the true y position of the element in the parent container.
   */
  get realY() {
    return this.target.localTransform.ty;
  }
  /**
   * Returns the true x scale of the target.
   *
   * When an element is in layout, the scale is an offset from 1.
   * This is the true x scale of the element.
   */
  get realScaleX() {
    return this.target.localTransform.a;
  }
  /**
   * Returns the true y scale of the target.
   *
   * When an element is in layout, the scale is an offset from 1.
   * This is the true y scale of the element.
   */
  get realScaleY() {
    return this.target.localTransform.d;
  }
  /**
   * Updates the layout style and triggers recalculation
   * @param style - New layout style to apply
   */
  setStyle(style) {
    const styles = formatStyles(this, style);
    const differentCustom = JSON.stringify(this._styles.custom) !== JSON.stringify(styles.custom);
    const differentYoga = JSON.stringify(this._styles.yoga) !== JSON.stringify(styles.yoga);
    const different = differentCustom || differentYoga;
    const hasTrackedChanges = this._trackedStyleKeys.some((key) => styles.custom[key] !== this._styles.custom[key]);
    this._styles = styles;
    if (hasTrackedChanges) {
      this._forceUpdate = true;
    }
    if (different) {
      applyStyle(this.yoga, this._styles.yoga);
      this.target._onUpdate();
      this.invalidateRoot();
    }
  }
  /** Marks the root layout as needing recalculation */
  invalidateRoot() {
    const root = this.getRoot();
    root._layout._isDirty = true;
    root._onUpdate();
    this._modificationCount++;
  }
  /**
   * Forces an update of the layout even if it hasn't changed the yoga node.
   * This is used to force an update when certain style properties change such as `objectFit`.
   * Or when you have changed something inside of Pixi that is not tracked by the layout system.
   */
  forceUpdate() {
    this._forceUpdate = true;
  }
  /**
   * Finds the root container by traversing up the layout tree
   * @returns The root container
   */
  getRoot() {
    var _a, _b;
    let root = this.target;
    while (((_a = root.parent) == null ? void 0 : _a._layout) || ((_b = root.parent) == null ? void 0 : _b.isOverflowContainer)) {
      root = root.parent;
      if (root.isOverflowContainer) {
        root = root.parent;
      }
    }
    return root;
  }
  /**
   * @ignore
   */
  _onChildAdded(pixiParent) {
    if (this.hasParent) return;
    this.hasParent = true;
    this.invalidateRoot();
    onChildAdded(this, pixiParent);
  }
  /**
   * @ignore
   */
  _onChildRemoved() {
    if (!this.hasParent) return;
    this.hasParent = false;
    this.invalidateRoot();
    onChildRemoved(this);
  }
  destroy() {
    this.invalidateRoot();
    this.yoga.free();
    this.target.off("added", this._onChildAdded, this);
    this.target.off("removed", this._onChildRemoved, this);
    this._styles = null;
    this._computedPixiLayout = null;
    this._computedLayout = null;
    this.target = null;
    this.hasParent = false;
  }
};
__publicField2(Layout, "defaultStyle", {
  leaf: {
    width: "intrinsic",
    height: "intrinsic"
  },
  container: {
    width: "auto",
    height: "auto"
  },
  shared: {
    transformOrigin: "50%",
    objectPosition: "center",
    flexShrink: 1,
    flexDirection: "row",
    alignContent: "stretch",
    flexWrap: "nowrap",
    overflow: "visible"
  }
});

// node_modules/@pixi/layout/dist/core/mixins/utils/calculateObjectFit.mjs
function calculateObjectFit(value, computedLayout, bounds) {
  let offsetScaleX = 1;
  let offsetScaleY = 1;
  switch (value) {
    case "fill":
      offsetScaleX = computedLayout.width / bounds.width;
      offsetScaleY = computedLayout.height / bounds.height;
      break;
    case "contain": {
      const scaleContain = Math.min(computedLayout.width / bounds.width, computedLayout.height / bounds.height);
      offsetScaleX = scaleContain;
      offsetScaleY = scaleContain;
      break;
    }
    case "cover": {
      const scaleCover = Math.max(computedLayout.width / bounds.width, computedLayout.height / bounds.height);
      offsetScaleX = scaleCover;
      offsetScaleY = scaleCover;
      break;
    }
    case "none":
      offsetScaleX = 1;
      offsetScaleY = 1;
      break;
    case "scale-down": {
      const scaleDown = Math.min(1, computedLayout.width / bounds.width, computedLayout.height / bounds.height);
      offsetScaleX = scaleDown;
      offsetScaleY = scaleDown;
      break;
    }
  }
  return {
    offsetScaleX,
    offsetScaleY
  };
}

// node_modules/@pixi/layout/dist/core/mixins/utils/baseComputeLayoutData.mjs
function baseComputeLayoutData(container, computedLayout, defaultObjectFit, anchor) {
  const bounds = container.getLocalBounds();
  const objectFit = container.layout.style.objectFit || defaultObjectFit;
  let { offsetScaleX, offsetScaleY } = calculateObjectFit(objectFit, computedLayout, bounds);
  const scaledBounds = {
    width: bounds.width * offsetScaleX,
    height: bounds.height * offsetScaleY
  };
  let { x: offsetX, y: offsetY } = calculatePositionSpecifier(
    container.layout.style.objectPosition,
    computedLayout,
    scaledBounds
  );
  if (anchor) {
    offsetX += bounds.width * offsetScaleX * anchor._x;
    offsetY += bounds.height * offsetScaleY * anchor._y;
  } else {
    offsetX -= bounds.minX * offsetScaleX;
    offsetY -= bounds.minY * offsetScaleY;
  }
  const applySizeDirectly = container.layout.style.applySizeDirectly;
  if (applySizeDirectly === true || // eslint-disable-next-line eqeqeq
  applySizeDirectly == void 0 && (container instanceof TilingSprite || container instanceof NineSliceSprite)) {
    container.width = bounds.width * offsetScaleX;
    container.height = bounds.height * offsetScaleY;
    offsetScaleX = 1;
    offsetScaleY = 1;
  }
  return {
    x: computedLayout.left,
    y: computedLayout.top,
    offsetX,
    offsetY,
    scaleX: offsetScaleX,
    scaleY: offsetScaleY
  };
}

// node_modules/@pixi/layout/dist/core/mixins/ContainerMixin.mjs
var visibility = Object.getOwnPropertyDescriptor(Container.prototype, "visible");
var mixin = {
  // Internal reference to the layout object
  _layout: null,
  /**
   * Gets the current layout associated with this container
   * @returns The container's layout or null if no layout is attached
   */
  get layout() {
    return this._layout ?? null;
  },
  /**
   * Sets the layout for this container
   * @param value - Layout options to apply, or null to remove layout
   */
  set layout(value) {
    value = value === true ? {} : value;
    if (!value) {
      if (this._layout) {
        this._layout.destroy();
        this._layout = null;
        this.updateLocalTransform = Container.prototype.updateLocalTransform;
        Object.defineProperty(Container.prototype, "visible", visibility);
      }
      return;
    }
    if (!this._layout) {
      this._layout = new Layout({ target: this });
      Object.defineProperty(Container.prototype, "visible", {
        ...visibility,
        set(visibleValue) {
          visibility.set.call(this, visibleValue);
          if (this.layout) {
            if (visibleValue && this.parent) {
              this.layout._onChildAdded(this.parent);
            } else {
              this.layout._onChildRemoved();
            }
          }
        }
      });
      if (this.parent && this.visible) {
        this._layout._onChildAdded(this.parent);
      }
    }
    this._layout.setStyle(value);
    this.updateLocalTransform = this.updateLocalTransformWithLayout;
    this._onUpdate();
  },
  /**
   * This function overrides how we calculate the local transform of the container.
   * For the layout, we need to not only calculate the transform matrix, but also
   * take into account the yoga layout's position and scale.
   */
  updateLocalTransformWithLayout() {
    const localTransformChangeId = this._didContainerChangeTick;
    if (this._didLocalTransformChangeId === localTransformChangeId) return;
    this._didLocalTransformChangeId = localTransformChangeId;
    const layout = this._layout;
    const { x, y, offsetX, offsetY, scaleX, scaleY, originX, originY } = layout._computedPixiLayout;
    const lt = this.localTransform;
    const { rotation, skew, scale, position: position2 } = this;
    const xRotY = rotation + skew._y;
    const xRotX = rotation - skew._x;
    const a = Math.cos(xRotY) * scale._x;
    const b = Math.sin(xRotY) * scale._x;
    const c = -Math.sin(xRotX) * scale._y;
    const d = Math.cos(xRotX) * scale._y;
    const tx = position2._x + x - originX * a - originY * c;
    const ty = position2._y + y - originX * b - originY * d;
    lt.a = a * scaleX;
    lt.b = b * scaleX;
    lt.c = c * scaleY;
    lt.d = d * scaleY;
    lt.tx = tx + (offsetX * a + offsetY * c) + originX;
    lt.ty = ty + (offsetX * b + offsetY * d) + originY;
  },
  /**
   * Apply the computed layout to the container
   * Converts Yoga layout information into PixiJS positioning
   * @param computedLayout - Layout data from Yoga engine
   * @returns Transformed position and scale data for this container
   * @memberof scene.Container#
   */
  computeLayoutData(computedLayout) {
    const layout = this._layout;
    const { isLeaf } = layout._styles.custom;
    if (isLeaf) {
      return baseComputeLayoutData(this, computedLayout, "fill");
    }
    return {
      x: computedLayout.left,
      y: computedLayout.top,
      offsetX: 0,
      offsetY: 0,
      scaleX: 1,
      scaleY: 1
    };
  }
};
extensions.mixin(Container, mixin);

// node_modules/@pixi/layout/dist/core/mixins/TextMixin.mjs
var tempScale = new Point(0, 0);
var mixin2 = {
  /**
   * Computes the layout data for the text element
   * @param computedLayout - The computed layout from Yoga
   * @returns The layout data for the text element
   */
  computeLayoutData(computedLayout) {
    const style = this._style;
    tempScale.copyFrom(this.scale);
    this.scale = 1;
    if (style.wordWrap) {
      style.wordWrapWidth = computedLayout.width;
    }
    let bounds = this.getLocalBounds();
    const objectFit = this.layout.style.objectFit || "scale-down";
    const { offsetScaleX, offsetScaleY } = calculateObjectFit(objectFit, computedLayout, bounds);
    if (style.wordWrap) {
      style.wordWrapWidth = computedLayout.width / Math.min(1, Math.max(offsetScaleX, offsetScaleY));
    }
    bounds = this.getLocalBounds();
    const scaledBounds = {
      width: bounds.width * offsetScaleX,
      height: bounds.height * offsetScaleY
    };
    let { x: offsetX, y: offsetY } = calculatePositionSpecifier(
      this.layout.style.objectPosition,
      computedLayout,
      scaledBounds
    );
    offsetX += bounds.width * offsetScaleX * this.anchor._x;
    offsetY += bounds.height * offsetScaleY * this.anchor._y;
    const applySizeDirectly = this.layout.style.applySizeDirectly;
    if (applySizeDirectly === true) {
      this.width = bounds.width * offsetScaleX;
      this.height = bounds.height * offsetScaleY;
    }
    this.scale.copyFrom(tempScale);
    return {
      x: computedLayout.left,
      y: computedLayout.top,
      offsetX,
      offsetY,
      scaleX: offsetScaleX,
      scaleY: offsetScaleY
    };
  }
};
extensions.mixin(AbstractText, mixin2);
var text = Object.getOwnPropertyDescriptor(AbstractText.prototype, "text");
Object.defineProperty(AbstractText.prototype, "text", {
  ...text,
  set(textString) {
    var _a;
    const currentText = text.get.call(this);
    text.set.call(this, textString);
    if (currentText === textString) return;
    (_a = this.layout) == null ? void 0 : _a.forceUpdate();
  }
});

// node_modules/@pixi/layout/dist/core/mixins/ViewContainerMixin.mjs
var mixin3 = {
  /**
   * Computes the layout data for the container
   * @param computedLayout - The computed layout from Yoga
   * @returns The layout data for the container
   */
  computeLayoutData(computedLayout) {
    return baseComputeLayoutData(this, computedLayout, "fill", this._anchor);
  }
};
extensions.mixin(ViewContainer, mixin3);

// node_modules/@pixi/layout/dist/index.mjs
extensions.add(LayoutSystem);
export {
  DebugRenderer,
  Layout,
  LayoutSystem,
  applyStyle,
  formatStyles,
  getNumberFromStyle,
  getPixiSize,
  getTypeFromStyle,
  getYoga,
  nearlyEqual,
  onChildAdded,
  onChildRemoved,
  setYoga
};
//# sourceMappingURL=@pixi_layout.js.map
