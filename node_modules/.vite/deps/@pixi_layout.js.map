{
  "version": 3,
  "sources": ["../../@pixi/layout/src/yoga.ts", "../../@pixi/layout/src/core/utils/getNumberFromStyle.ts", "../../@pixi/layout/src/core/mixins/utils/position/calculateWithDoubleValue.ts", "../../@pixi/layout/src/core/mixins/utils/position/calculateWithQuadValue.ts", "../../@pixi/layout/src/core/mixins/utils/position/calculateWithSingleValue.ts", "../../@pixi/layout/src/core/mixins/utils/calculatePositionSpecifier.ts", "../../@pixi/layout/src/core/utils/getPixiSize.ts", "../../@pixi/layout/src/core/utils/nearlyEqual.ts", "../../@pixi/layout/src/core/utils/throttle.ts", "../../@pixi/layout/src/core/LayoutSystem.ts", "../../@pixi/layout/src/core/style/applyStyle.ts", "../../@pixi/layout/src/core/style/formatStyles.ts", "../../@pixi/layout/src/core/utils/sort-children.ts", "../../@pixi/layout/src/core/Layout.ts", "../../@pixi/layout/src/core/mixins/utils/calculateObjectFit.ts", "../../@pixi/layout/src/core/mixins/utils/baseComputeLayoutData.ts", "../../@pixi/layout/src/core/mixins/ContainerMixin.ts", "../../@pixi/layout/src/core/mixins/TextMixin.ts", "../../@pixi/layout/src/core/mixins/ViewContainerMixin.ts", "../../@pixi/layout/src/index.ts"],
  "sourcesContent": ["import { type loadYoga } from 'yoga-layout/load';\n\nexport type Yoga = Awaited<ReturnType<typeof loadYoga>>;\n\nlet yoga: Yoga;\n\n/**\n * Get the Yoga instance.\n * Yoga is a dynamically loaded module, so it is not available until it is loaded.\n */\nexport function getYoga(): Yoga {\n    return yoga;\n}\n\n/**\n * Set the Yoga instance.\n * @param newYoga The Yoga instance.\n */\nexport function setYoga(newYoga: Yoga) {\n    yoga = newYoga;\n}\n", "import { type NumberValue, type PositionKeyword } from '../types';\n\n/**\n * Converts a style value to a number. If the value is a percentage string,\n * it calculates the number based on the given size.\n *\n * @param value - The style value to convert. It can be a number or a percentage string (e.g., '50%').\n * @param size - The size to use for percentage calculations.\n * @returns The numeric value. If the input is a percentage string, it returns the calculated number based on the size.\n *          If the input is a number, it returns the number itself. If the input is neither, it returns 0.\n */\nexport function getNumberFromStyle(value: NumberValue, size?: number): number {\n    if (!value) return 0;\n    if (typeof value === 'number') {\n        // If the value is already a number, return it as is.\n        return value;\n    } else if (typeof value === 'string' && value.endsWith('%')) {\n        size ??= 1;\n\n        // If the value is a percentage string, calculate the number based on the size.\n        return size * (parseFloat(value) / 100);\n    } else if (!Number.isNaN(parseFloat(value))) {\n        // If the value is a number string, parse it as a number.\n        return parseFloat(value);\n    }\n\n    // If the value is neither a number nor a percentage string, return the value as a number.\n    return 0;\n}\n\n/**\n * Determines the type of a style value.\n *\n * @param value - The style value to check.\n * @returns The type of the style value. It can be 'number', 'percentage', or 'keyword'.\n */\nexport function getTypeFromStyle(value: NumberValue | PositionKeyword): 'number' | 'percentage' | 'keyword' {\n    if (typeof value === 'number') return 'number';\n    if (value.endsWith('%')) return 'percentage';\n    if (Number.isNaN(parseInt(value, 10))) return 'keyword';\n\n    return 'number';\n}\n", "import { type PointData, type Size } from 'pixi.js';\nimport { type ComputedLayout, type NumberValue, type PositionSpecifier } from '../../../types';\nimport { getNumberFromStyle, getTypeFromStyle } from '../../../utils/getNumberFromStyle';\nimport { type ObjectPositionValue } from '../calculatePositionSpecifier';\n\n/**\n * Calculates the position for a centered element along the specified dimension\n *\n * @param dimension - Which dimension to calculate ('width' or 'height')\n * @param computedLayout - The computed layout from Yoga\n * @param visualBounds - The visual bounds of the element being positioned\n * @returns The coordinate value that centers the element\n */\nfunction calculateCenterPosition(\n    dimension: 'width' | 'height',\n    computedLayout: ComputedLayout,\n    visualBounds: Size,\n): number {\n    return (computedLayout[dimension] - visualBounds[dimension]) / 2;\n}\n\n/**\n * Calculates position for numeric values (px, %, etc)\n *\n * @param value - The position value to process\n * @param valueType - Type of the value ('percentage', 'pixel', etc)\n * @param dimension - Which dimension to calculate ('width' or 'height')\n * @param computedLayout - The computed layout from Yoga\n * @param visualBounds - The visual bounds of the element being positioned\n * @returns The calculated coordinate value\n */\nfunction calculateNonKeywordPosition(\n    value: ObjectPositionValue,\n    valueType: string,\n    dimension: 'width' | 'height',\n    computedLayout: ComputedLayout,\n    visualBounds: Size,\n): number {\n    const multiple = valueType === 'percentage' ? computedLayout[dimension] - visualBounds[dimension] : 1;\n\n    return getNumberFromStyle(value as NumberValue) * multiple;\n}\n\n/**\n * Calculates position when two values are provided (e.g., \"top center\", \"10% 20px\")\n * This implements CSS object-position behavior with two values\n *\n * @param tokens - Array of position tokens (should be exactly two)\n * @param computedLayout - The computed layout from Yoga\n * @param visualBounds - The visual bounds of the element being positioned\n * @returns Object with x and y coordinates for positioning\n */\nexport function calculateWithDoubleValue(\n    tokens: PositionSpecifier[],\n    computedLayout: ComputedLayout,\n    visualBounds: Size,\n): PointData {\n    const [first, second] = tokens as [ObjectPositionValue, ObjectPositionValue];\n    const firstType = getTypeFromStyle(first);\n    const secondType = getTypeFromStyle(second);\n    const result = { x: undefined, y: undefined } as unknown as PointData;\n\n    // Process first value\n    switch (first) {\n        case 'top':\n            result.y = 0;\n            break;\n        case 'bottom':\n            result.y = computedLayout.height - visualBounds.height;\n            break;\n        case 'center':\n            if (second === 'left' || second === 'right') {\n                result.y = calculateCenterPosition('height', computedLayout, visualBounds);\n            } else {\n                result.x = calculateCenterPosition('width', computedLayout, visualBounds);\n            }\n            break;\n        case 'left':\n            result.x = 0;\n            break;\n        case 'right':\n            result.x = computedLayout.width - visualBounds.width;\n            break;\n        default: {\n            const dimension = second === 'top' || second === 'bottom' || secondType !== 'keyword' ? 'width' : 'height';\n            const target = dimension === 'width' ? 'x' : 'y';\n\n            result[target] = calculateNonKeywordPosition(first, firstType, dimension, computedLayout, visualBounds);\n        }\n    }\n\n    // Process second value\n    switch (second) {\n        case 'top':\n            result.y = 0;\n            break;\n        case 'bottom':\n            result.y = computedLayout.height - visualBounds.height;\n            break;\n        case 'center':\n            if (result.y === undefined) {\n                result.y = calculateCenterPosition('height', computedLayout, visualBounds);\n            } else {\n                result.x = calculateCenterPosition('width', computedLayout, visualBounds);\n            }\n            break;\n        case 'left':\n            result.x = 0;\n            break;\n        case 'right':\n            result.x = computedLayout.width - visualBounds.width;\n            break;\n        default: {\n            const target = result.y === undefined ? 'y' : 'x';\n            const dimension = target === 'y' ? 'height' : 'width';\n\n            result[target] = calculateNonKeywordPosition(second, secondType, dimension, computedLayout, visualBounds);\n        }\n    }\n\n    return result;\n}\n", "import { type PointData, type Size } from 'pixi.js';\nimport { type ComputedLayout, type NumberValue, type PositionKeyword, type PositionSpecifier } from '../../../types';\nimport { getNumberFromStyle, getTypeFromStyle } from '../../../utils/getNumberFromStyle';\nimport { type ObjectPositionValue } from '../calculatePositionSpecifier';\nimport { calculateWithDoubleValue } from './calculateWithDoubleValue';\n\n/**\n * Calculates the offset along an axis based on a keyword and value\n * Used for computing position adjustments from values like \"left 10px\" or \"bottom 20%\"\n *\n * @param keyword - The positioning keyword (left, right, top, bottom)\n * @param value - The numeric value of the offset\n * @param type - The type of value (percentage, pixel, etc)\n * @param bounds - The relevant dimension (width or height) to calculate percentage values\n * @returns The calculated offset value\n */\nfunction calculateAxisOffset(keyword: PositionKeyword, value: number, type: string, bounds: number): number {\n    const isNegativeOffset = keyword === 'right' || keyword === 'bottom';\n    const offset = type === 'percentage' ? value * bounds : value;\n\n    return isNegativeOffset ? -offset : offset;\n}\n\n/**\n * Calculates position when four values are provided (e.g., \"top 10px right 20px\")\n * Handles CSS object-position with format: <keyword> <offset> <keyword> <offset>\n *\n * @param tokens - Array of four position tokens\n * @param computedLayout - The computed layout from Yoga\n * @param visualBounds - The visual bounds of the element being positioned\n * @returns Object with x and y coordinates for positioning\n */\nexport function calculateWithQuadValue(\n    tokens: PositionSpecifier[],\n    computedLayout: ComputedLayout,\n    visualBounds: Size,\n): PointData {\n    const [first, second, third, fourth] = tokens as [\n        ObjectPositionValue,\n        NumberValue,\n        ObjectPositionValue,\n        NumberValue,\n    ];\n\n    const firstType = getTypeFromStyle(first);\n    const secondType = getTypeFromStyle(second);\n    const thirdType = getTypeFromStyle(third);\n    const fourthType = getTypeFromStyle(fourth);\n\n    if (secondType === 'keyword' || fourthType === 'keyword') {\n        throw new Error('Invalid objectPosition value: second and fourth values must be numbers or percentages');\n    }\n    if (firstType !== 'keyword' || thirdType !== 'keyword') {\n        throw new Error('Invalid objectPosition value: first and third values must be keywords');\n    }\n\n    const basePosition = calculateWithDoubleValue([first, third], computedLayout, visualBounds);\n    const result = { ...basePosition };\n\n    const secondValue = getNumberFromStyle(second);\n    const fourthValue = getNumberFromStyle(fourth);\n\n    // Process first pair (first + second)\n    if (first === 'left' || first === 'right') {\n        result.x = basePosition.x + calculateAxisOffset(first, secondValue, secondType, visualBounds.width);\n    } else if (first === 'top' || first === 'bottom') {\n        result.y = basePosition.y + calculateAxisOffset(first, secondValue, secondType, visualBounds.height);\n    }\n\n    // Process second pair (third + fourth)\n    if (third === 'left' || third === 'right') {\n        result.x = basePosition.x + calculateAxisOffset(third, fourthValue, fourthType, visualBounds.width);\n    } else if (third === 'top' || third === 'bottom') {\n        result.y = basePosition.y + calculateAxisOffset(third, fourthValue, fourthType, visualBounds.height);\n    }\n\n    return result;\n}\n", "import { type PointData, type Size } from 'pixi.js';\nimport { type ComputedLayout, type NumberValue, type PositionKeyword, type PositionSpecifier } from '../../../types';\nimport { getNumberFromStyle, getTypeFromStyle } from '../../../utils/getNumberFromStyle';\n\n/**\n * Calculates position when a single value is provided (e.g., \"center\", \"top\", \"50%\")\n * This implements CSS object-position behavior with a single value\n *\n * @param tokens - Array containing a single position token\n * @param computedLayout - The computed layout from Yoga\n * @param visualBounds - The visual bounds of the element being positioned\n * @returns Object with x and y coordinates for positioning\n */\nexport function calculateWithSingleValue(\n    tokens: PositionSpecifier[],\n    computedLayout: ComputedLayout,\n    visualBounds: Size,\n): PointData {\n    const keyword = tokens[0]! as NumberValue | PositionKeyword;\n    const result = { x: undefined, y: undefined } as unknown as PointData;\n\n    switch (keyword) {\n        case 'top':\n            result.y = 0;\n            result.x = (computedLayout.width - visualBounds.width) / 2;\n            break;\n        case 'bottom':\n            result.y = computedLayout.height - visualBounds.height;\n            result.x = (computedLayout.width - visualBounds.width) / 2;\n            break;\n        case 'left':\n            result.x = 0;\n            result.y = (computedLayout.height - visualBounds.height) / 2;\n            break;\n        case 'right':\n            result.x = computedLayout.width - visualBounds.width;\n            result.y = (computedLayout.height - visualBounds.height) / 2;\n            break;\n        case 'center':\n            result.x = (computedLayout.width - visualBounds.width) / 2;\n            result.y = (computedLayout.height - visualBounds.height) / 2;\n            break;\n        default: {\n            const isPercentage = getTypeFromStyle(keyword) === 'percentage';\n            const multiple = isPercentage ? computedLayout.width - visualBounds.width : 1;\n\n            // Handle single number value as x coordinate\n            result.x = getNumberFromStyle(keyword) * multiple;\n            result.y = (computedLayout.height - visualBounds.height) / 2;\n        }\n    }\n\n    return result;\n}\n", "import { type PointData, type Size } from 'pixi.js';\nimport { type ComputedLayout, type NumberValue, type PositionKeyword, type PositionSpecifier } from '../../types';\nimport { calculateWithDoubleValue } from './position/calculateWithDoubleValue';\nimport { calculateWithQuadValue } from './position/calculateWithQuadValue';\nimport { calculateWithSingleValue } from './position/calculateWithSingleValue';\n\n/**\n * Represents a single position token which can be either a numeric value or a keyword\n * Examples: \"center\", \"left\", \"50%\", \"10px\"\n */\nexport type ObjectPositionValue = NumberValue | PositionKeyword;\n\n/**\n * Calculates the position of content within its bounds based on PositionSpecifier value\n * Implements CSS-like object-position/transform-origin behavior for flexible content positioning\n *\n * The function supports multiple formats:\n * - Single value: \"center\", \"top\", \"50%\"\n * - Double value: \"top left\", \"center 20%\", \"10px 30px\"\n * - Quad value: \"top 10px right 20%\"\n *\n * @param value - The value from layout style\n * @param computedLayout - The computed layout dimensions from Yoga\n * @param visualBounds - The visual bounds of the content being positioned\n * @returns Calculated x,y coordinates for content positioning\n */\nexport function calculatePositionSpecifier(\n    value: PositionSpecifier | undefined,\n    computedLayout: ComputedLayout,\n    visualBounds: Size,\n): PointData {\n    if (!value) return { x: 0, y: 0 };\n\n    const tokens: PositionSpecifier[] =\n        typeof value === 'string' ? (value.split(' ') as PositionSpecifier[]) : ([value] as PositionSpecifier[]);\n\n    switch (tokens.length) {\n        case 1:\n            return calculateWithSingleValue(tokens, computedLayout, visualBounds);\n        case 2:\n            return calculateWithDoubleValue(tokens, computedLayout, visualBounds);\n        case 4:\n            return calculateWithQuadValue(tokens, computedLayout, visualBounds);\n        default:\n            throw new Error('Invalid objectPosition value: must have 1, 2, or 4 values');\n    }\n}\n", "import { Bounds, type Size } from 'pixi.js';\nimport { type Layout } from '../Layout';\n\nconst tempBounds = new Bounds();\nconst temp = { width: 0, height: 0 };\n\n/**\n * Retrieves the absolute size of a PixiJS container\n * @param layout - The layout to retrieve the size from\n * @returns The size of the PixiJS container\n */\nexport function getPixiSize(layout: Layout): Size {\n    const bounds = layout.target.getLocalBounds(tempBounds);\n    const scale = layout.target.scale;\n\n    temp.width = Math.abs(bounds.width * scale.x);\n    temp.height = Math.abs(bounds.height * scale.y);\n\n    return temp;\n}\n", "/**\n * Check if two numbers are nearly equal.\n * @param a - The first number.\n * @param b - The second number.\n * @param EPSILON - The epsilon value.\n * @returns True if the numbers are nearly equal, false otherwise.\n */\nexport function nearlyEqual(a: number, b: number, EPSILON = 0.49) {\n    return Math.abs(a - b) < EPSILON;\n}\n", "const throttleMap = new Map<\n    (...params: any[]) => void,\n    { throttledFunction: (...params: any[]) => void; args: any[] | null }\n>();\n\n/**\n * Lets you call a function and have it throttled by a certain delay.\n * Useful for when a function may be spammed!\n *\n * @example\n * ```\n * function resize(w, h){\n *  console.log('resized', w, h);\n * }\n *\n * window.onResize = ()=>{\n *  throttle(resize, 100)(window.innerWidth, window.innerHeight);\n * }\n * ```\n *\n * @param fun - the function you want throttled\n * @param delay - how long until the function is executed\n */\nexport function throttle(fun: (...params: any[]) => void, delay = 100, scope?: any): (...params: any[]) => void {\n    if (!throttleMap.has(fun)) {\n        let timerId: NodeJS.Timeout | number | null = null;\n\n        const throttledFunction = (...args: any): void => {\n            throttleMap.get(fun)!.args = args;\n\n            if (timerId) return;\n\n            const callFun = (): void => {\n                timerId = null;\n\n                const latestArgs = throttleMap.get(fun)!.args;\n\n                if (scope) {\n                    fun.call(scope, ...latestArgs!);\n                } else {\n                    fun(...latestArgs!);\n                }\n            };\n\n            if (delay === 0) {\n                callFun();\n            } else {\n                timerId = setTimeout(callFun, delay);\n            }\n        };\n\n        throttleMap.set(fun, { throttledFunction, args: null });\n    }\n\n    return throttleMap.get(fun)!.throttledFunction;\n}\n", "import { type Container, ExtensionType, type System } from 'pixi.js';\nimport { Direction, loadYoga } from 'yoga-layout/load';\nimport { type OverflowContainer } from '../components/LayoutContainer';\nimport { setYoga } from '../yoga';\nimport { calculatePositionSpecifier } from './mixins/utils/calculatePositionSpecifier';\nimport { getPixiSize } from './utils/getPixiSize';\nimport { nearlyEqual } from './utils/nearlyEqual';\nimport { throttle as throttleFn } from './utils/throttle';\n\nimport type { DebugRenderer } from './debug/DebugRenderer';\n\n/**\n * Options for the layout system\n */\nexport interface LayoutSystemOptions {\n    layout: {\n        /** Whether the layout system should automatically update the layout when it detects changes */\n        autoUpdate: boolean;\n        /** Whether to enable debug mode */\n        enableDebug: boolean;\n        /** The number of modifications to trigger rendering the heatmap */\n        debugModificationCount: number;\n        /** The length of time in milliseconds to throttle the calculating auto layout values */\n        throttle: number;\n    };\n}\n\n/**\n * The layout system is responsible for updating the layout of the containers\n * @memberof rendering\n */\nexport class LayoutSystem implements System<LayoutSystemOptions> {\n    /** @ignore */\n    public static extension = {\n        type: [ExtensionType.WebGLSystem, ExtensionType.WebGPUSystem],\n        name: 'layout',\n    } as const;\n\n    /**\n     * Whether the layout system should automatically update the layout when it detects changes\n     * @default true\n     */\n    public autoUpdate = true;\n\n    private _debugEnabled = false;\n    private _debugRenderer: DebugRenderer | null = null;\n\n    private _throttledUpdateSize!: (container: Container) => void;\n    private _throttle = 100;\n    private _modificationCount = 50;\n\n    /**\n     * Initializes the layout system by loading the Yoga library asynchronously\n     * @returns A promise that resolves when the system is ready\n     */\n    public async init(options?: LayoutSystemOptions) {\n        setYoga(await loadYoga());\n        const { layout } = options ?? {};\n        const { autoUpdate, enableDebug, throttle, debugModificationCount } = layout ?? {};\n\n        if (enableDebug) {\n            void this.enableDebug(true);\n        }\n\n        if (autoUpdate !== undefined) {\n            this.autoUpdate = autoUpdate;\n        }\n\n        this._throttle = throttle ?? this._throttle;\n        this._throttledUpdateSize = throttleFn((container: Container) => this._updateSize(container), this._throttle);\n\n        this._modificationCount = debugModificationCount ?? this._modificationCount;\n    }\n\n    /**\n     * Toggles the debug mode for the layout system\n     * @param value - Whether to enable or disable debug mode\n     */\n    public async enableDebug(value = !this._debugEnabled) {\n        this._debugEnabled = value;\n\n        if (!this._debugRenderer) {\n            const res = await import('./debug/DebugRenderer');\n\n            this._debugRenderer = new res.DebugRenderer();\n        }\n\n        if (!this._debugEnabled) {\n            this._debugRenderer!.reset();\n        }\n    }\n\n    /**\n     * Updates the layout of the container and its children\n     * @param container - The container to update the layout for\n     */\n    public update(container: Container) {\n        if (this._debugEnabled && this._debugRenderer) {\n            this._debugRenderer.reset();\n            container.addChild(this._debugRenderer.holder);\n        }\n\n        // Before we start updating the layout, we need to ensure that the size of the yoga nodes are up to date\n        this._throttledUpdateSize(container);\n\n        // loop through entire scene and check for any layout updates!\n        this.updateLayout(container);\n    }\n\n    public prerender({ container }: { container: Container }) {\n        if (this.autoUpdate) {\n            this.update(container);\n        }\n    }\n\n    /**\n     * Updates the size of the yoga nodes for the containers that use pixi size\n     * @param container - The container to update the size for\n     */\n    private _updateSize(container: Container) {\n        const layout = container._layout;\n\n        if (layout) {\n            const layoutStyles = layout.style;\n\n            if (layoutStyles.width === 'intrinsic' || layoutStyles.height === 'intrinsic') {\n                const size = getPixiSize(layout);\n\n                if (layoutStyles.width === 'intrinsic') {\n                    const currentWidth = layout.yoga.getWidth().value;\n\n                    if (!nearlyEqual(currentWidth, size.width)) {\n                        layout.yoga.setWidth(size.width);\n                        layout.invalidateRoot();\n                    }\n                }\n                if (layoutStyles.height === 'intrinsic') {\n                    const currentHeight = layout.yoga.getHeight().value;\n\n                    if (!nearlyEqual(currentHeight, size.height)) {\n                        layout.yoga.setHeight(size.height);\n                        layout.invalidateRoot();\n                    }\n                }\n            }\n\n            // if the container is not visible, we need to remove it from the layout\n            if (!container.visible) {\n                layout._onChildRemoved();\n\n                return;\n            }\n        }\n\n        for (let i = 0; i < container.children.length; i++) {\n            this._updateSize(container.children[i]!);\n        }\n    }\n\n    /**\n     * Updates the layout of the container and its children\n     * @param container - The container to update the layout for\n     */\n    private updateLayout(container: Container) {\n        const layout = container._layout;\n\n        // return early if the container is not visible\n        if (!container.visible) {\n            return;\n        }\n\n        if (layout) {\n            const yogaNode = layout.yoga;\n            const layoutStyles = layout.style;\n\n            const isOverflowContainer = (container.parent as OverflowContainer)?.isOverflowContainer;\n            const hasParentLayout = container.parent?._layout;\n\n            if (!hasParentLayout && !isOverflowContainer) {\n                if (layout._isDirty) {\n                    layout._isDirty = false;\n                    yogaNode.calculateLayout(\n                        layoutStyles.width as number, // TODO: if this is not a number, it will not work\n                        layoutStyles.height as number,\n                        yogaNode.getDirection() ?? Direction.LTR,\n                    );\n                }\n            }\n\n            if (yogaNode.hasNewLayout() || layout._forceUpdate) {\n                // Reset the flag\n                yogaNode.markLayoutSeen();\n                layout._forceUpdate = false;\n\n                layout._computedLayout = yogaNode.getComputedLayout();\n                const res = calculatePositionSpecifier(layoutStyles.transformOrigin, layout._computedLayout, {\n                    width: 0,\n                    height: 0,\n                });\n\n                layout._computedPixiLayout = {\n                    ...container.computeLayoutData!(layout._computedLayout),\n                    originX: res.x,\n                    originY: res.y,\n                };\n\n                container.emit('layout', layout);\n                container.onLayout?.(layout);\n                container._onUpdate();\n            }\n\n            if (this._debugEnabled) {\n                if (\n                    layout._styles.custom.debug ||\n                    (layout._modificationCount > this._modificationCount && layout._styles.custom.debugHeat !== false)\n                ) {\n                    this._debugRenderer?.render(layout);\n                }\n            }\n        }\n\n        // update the children!\n        for (let i = 0; i < container.children.length; i++) {\n            this.updateLayout(container.children[i]!);\n        }\n    }\n\n    /**\n     * @ignore\n     */\n    public destroy(): void {\n        if (!this._debugEnabled && this._debugRenderer) {\n            this._debugRenderer!.destroy();\n        }\n    }\n}\n", "import {\n    Align,\n    BoxSizing,\n    Direction,\n    Display,\n    Edge,\n    FlexDirection,\n    Gutter,\n    Justify,\n    type Node as YogaNode,\n    Overflow,\n    PositionType,\n    Wrap,\n} from 'yoga-layout/load';\nimport { type AlignContent, type AlignItems, type JustifyContent, type YogaStyles } from './yogaStyles';\n\nconst ALIGN_CONTENT_MAP: Record<AlignContent, Align> = {\n    'flex-start': Align.FlexStart,\n    'flex-end': Align.FlexEnd,\n    center: Align.Center,\n    stretch: Align.Stretch,\n    'space-between': Align.SpaceBetween,\n    'space-around': Align.SpaceAround,\n    'space-evenly': Align.SpaceEvenly,\n} as const;\n\nconst ALIGN_ITEMS_MAP: Record<AlignItems, Align> = {\n    'flex-start': Align.FlexStart,\n    'flex-end': Align.FlexEnd,\n    center: Align.Center,\n    stretch: Align.Stretch,\n    baseline: Align.Baseline,\n} as const;\n\nconst BOX_SIZING_MAP: Record<'border-box' | 'content-box', BoxSizing> = {\n    'border-box': BoxSizing.BorderBox,\n    'content-box': BoxSizing.ContentBox,\n} as const;\n\nconst DIRECTION_MAP: Record<'ltr' | 'rtl', Direction> = {\n    ltr: Direction.LTR,\n    rtl: Direction.RTL,\n} as const;\n\nconst DISPLAY_MAP: Record<'none' | 'flex' | 'contents', Display> = {\n    none: Display.None,\n    flex: Display.Flex,\n    contents: Display.Contents,\n} as const;\n\nconst FLEX_DIRECTION_MAP: Record<'row' | 'column' | 'row-reverse' | 'column-reverse', FlexDirection> = {\n    row: FlexDirection.Row,\n    column: FlexDirection.Column,\n    'row-reverse': FlexDirection.RowReverse,\n    'column-reverse': FlexDirection.ColumnReverse,\n} as const;\n\nconst FLEX_WRAP_MAP: Record<'wrap' | 'nowrap' | 'wrap-reverse', Wrap> = {\n    wrap: Wrap.Wrap,\n    nowrap: Wrap.NoWrap,\n    'wrap-reverse': Wrap.WrapReverse,\n} as const;\n\nconst JUSTIFY_CONTENT_MAP: Record<JustifyContent, Justify> = {\n    'flex-start': Justify.FlexStart,\n    'flex-end': Justify.FlexEnd,\n    center: Justify.Center,\n    'space-between': Justify.SpaceBetween,\n    'space-around': Justify.SpaceAround,\n    'space-evenly': Justify.SpaceEvenly,\n} as const;\n\nconst OVERFLOW_MAP: Record<'visible' | 'hidden' | 'scroll', Overflow> = {\n    visible: Overflow.Visible,\n    hidden: Overflow.Hidden,\n    scroll: Overflow.Scroll,\n} as const;\n\nconst POSITION_MAP: Record<'absolute' | 'relative' | 'static', PositionType> = {\n    absolute: PositionType.Absolute,\n    relative: PositionType.Relative,\n    static: PositionType.Static,\n} as const;\n\nconst styleSetters: Record<keyof YogaStyles, (node: YogaNode, value: any) => void> = {\n    alignContent: (node, value) => node.setAlignContent(alignContent(value)),\n    alignItems: (node, value) => node.setAlignItems(alignItems(value)),\n    alignSelf: (node, value) => node.setAlignSelf(alignItems(value)),\n    aspectRatio: (node, value) => node.setAspectRatio(value),\n    borderBottomWidth: (node, value) => node.setBorder(Edge.Bottom, value),\n    borderEndWidth: (node, value) => node.setBorder(Edge.End, value),\n    borderLeftWidth: (node, value) => node.setBorder(Edge.Left, value),\n    borderRightWidth: (node, value) => node.setBorder(Edge.Right, value),\n    borderStartWidth: (node, value) => node.setBorder(Edge.Start, value),\n    borderTopWidth: (node, value) => node.setBorder(Edge.Top, value),\n    borderWidth: (node, value) => node.setBorder(Edge.All, value),\n    borderInlineWidth: (node, value) => node.setBorder(Edge.Horizontal, value),\n    borderBlockWidth: (node, value) => node.setBorder(Edge.Vertical, value),\n    bottom: (node, value) => node.setPosition(Edge.Bottom, value),\n    boxSizing: (node, value) => node.setBoxSizing(boxSizing(value)),\n    direction: (node, value) => node.setDirection(direction(value)),\n    display: (node, value) => node.setDisplay(display(value)),\n    end: (node, value) => node.setPosition(Edge.End, value),\n    flex: (node, value) => node.setFlex(value),\n    flexBasis: (node, value) => node.setFlexBasis(value),\n    flexDirection: (node, value) => node.setFlexDirection(flexDirection(value)),\n    rowGap: (node, value) => node.setGap(Gutter.Row, value),\n    gap: (node, value) => node.setGap(Gutter.All, value),\n    columnGap: (node, value) => node.setGap(Gutter.Column, value),\n    flexGrow: (node, value) => node.setFlexGrow(value),\n    flexShrink: (node, value) => node.setFlexShrink(value),\n    flexWrap: (node, value) => node.setFlexWrap(flexWrap(value)),\n    height: (node, value) => node.setHeight(value),\n    justifyContent: (node, value) => node.setJustifyContent(justifyContent(value)),\n    left: (node, value) => node.setPosition(Edge.Left, value),\n    margin: (node, value) => node.setMargin(Edge.All, value),\n    marginBottom: (node, value) => node.setMargin(Edge.Bottom, value),\n    marginEnd: (node, value) => node.setMargin(Edge.End, value),\n    marginLeft: (node, value) => node.setMargin(Edge.Left, value),\n    marginRight: (node, value) => node.setMargin(Edge.Right, value),\n    marginStart: (node, value) => node.setMargin(Edge.Start, value),\n    marginTop: (node, value) => node.setMargin(Edge.Top, value),\n    marginInline: (node, value) => node.setMargin(Edge.Horizontal, value),\n    marginBlock: (node, value) => node.setMargin(Edge.Vertical, value),\n    maxHeight: (node, value) => node.setMaxHeight(value),\n    maxWidth: (node, value) => node.setMaxWidth(value),\n    minHeight: (node, value) => node.setMinHeight(value),\n    minWidth: (node, value) => node.setMinWidth(value),\n    overflow: (node, value) => node.setOverflow(overflow(value)),\n    padding: (node, value) => node.setPadding(Edge.All, value),\n    paddingBottom: (node, value) => node.setPadding(Edge.Bottom, value),\n    paddingEnd: (node, value) => node.setPadding(Edge.End, value),\n    paddingLeft: (node, value) => node.setPadding(Edge.Left, value),\n    paddingRight: (node, value) => node.setPadding(Edge.Right, value),\n    paddingStart: (node, value) => node.setPadding(Edge.Start, value),\n    paddingTop: (node, value) => node.setPadding(Edge.Top, value),\n    paddingInline: (node, value) => node.setPadding(Edge.Horizontal, value),\n    paddingBlock: (node, value) => node.setPadding(Edge.Vertical, value),\n    position: (node, value) => node.setPositionType(position(value)),\n    right: (node, value) => node.setPosition(Edge.Right, value),\n    start: (node, value) => node.setPosition(Edge.Start, value),\n    top: (node, value) => node.setPosition(Edge.Top, value),\n    insetInline: (node, value) => node.setPosition(Edge.Horizontal, value),\n    insetBlock: (node, value) => node.setPosition(Edge.Vertical, value),\n    inset: (node, value) => node.setPosition(Edge.All, value),\n    width: (node, value) => node.setWidth(value),\n} as const;\n\nfunction alignContent(str: keyof typeof ALIGN_CONTENT_MAP): Align {\n    if (str in ALIGN_CONTENT_MAP) return ALIGN_CONTENT_MAP[str];\n\n    throw new Error(`\"${str}\" is not a valid value for alignContent`);\n}\n\nfunction alignItems(str: keyof typeof ALIGN_ITEMS_MAP): Align {\n    if (str in ALIGN_ITEMS_MAP) return ALIGN_ITEMS_MAP[str];\n\n    throw new Error(`\"${str}\" is not a valid value for alignItems`);\n}\n\nfunction boxSizing(str: keyof typeof BOX_SIZING_MAP): BoxSizing {\n    if (str in BOX_SIZING_MAP) return BOX_SIZING_MAP[str];\n\n    throw new Error(`\"${str}\" is not a valid value for boxSizing`);\n}\n\nfunction direction(str: keyof typeof DIRECTION_MAP): Direction {\n    if (str in DIRECTION_MAP) return DIRECTION_MAP[str];\n\n    throw new Error(`\"${str}\" is not a valid value for direction`);\n}\n\nfunction display(str: keyof typeof DISPLAY_MAP): Display {\n    if (str in DISPLAY_MAP) return DISPLAY_MAP[str];\n\n    throw new Error(`\"${str}\" is not a valid value for display`);\n}\n\nfunction flexDirection(str: keyof typeof FLEX_DIRECTION_MAP): FlexDirection {\n    if (str in FLEX_DIRECTION_MAP) return FLEX_DIRECTION_MAP[str];\n\n    throw new Error(`\"${str}\" is not a valid value for flexDirection`);\n}\n\nfunction flexWrap(str: keyof typeof FLEX_WRAP_MAP): Wrap {\n    if (str in FLEX_WRAP_MAP) return FLEX_WRAP_MAP[str];\n\n    throw new Error(`\"${str}\" is not a valid value for flexWrap`);\n}\n\nfunction justifyContent(str: keyof typeof JUSTIFY_CONTENT_MAP): Justify {\n    if (str in JUSTIFY_CONTENT_MAP) return JUSTIFY_CONTENT_MAP[str];\n\n    throw new Error(`\"${str}\" is not a valid value for justifyContent`);\n}\n\nfunction overflow(str: keyof typeof OVERFLOW_MAP): Overflow {\n    if (str in OVERFLOW_MAP) return OVERFLOW_MAP[str];\n\n    throw new Error(`\"${str}\" is not a valid value for overflow`);\n}\n\nfunction position(str: keyof typeof POSITION_MAP): PositionType {\n    if (str in POSITION_MAP) return POSITION_MAP[str];\n\n    throw new Error(`\"${str}\" is not a valid value for position`);\n}\n\n/**\n * Applies CSS-like flex styles to a Yoga node\n * Maps style properties to appropriate Yoga API calls\n *\n * @param node - The Yoga node to apply styles to\n * @param style - CSS-like flex style object\n */\nexport function applyStyle(node: YogaNode, style: YogaStyles = {}): void {\n    for (const [key, value] of Object.entries(style)) {\n        try {\n            const setter = styleSetters[key as keyof YogaStyles];\n\n            if (setter) {\n                setter(node, value);\n            }\n        } catch (_e) {\n            // Fail gracefully\n        }\n    }\n\n    // if both left and right are set, width is set to auto\n    // otherwise set the current width either from style or discovered size\n    if (style.width !== undefined) {\n        const widthValue = style.left !== undefined && style.right !== undefined ? 'auto' : style.width;\n\n        node.setWidth(widthValue as number);\n    }\n\n    // if both top and bottom are set, height is set to auto\n    // otherwise set the current height either from style or discovered size\n    if (style.height !== undefined) {\n        const heightValue = style.top !== undefined && style.bottom !== undefined ? 'auto' : style.height;\n\n        node.setHeight(heightValue as number);\n    }\n}\n", "import { ViewContainer } from 'pixi.js';\nimport { Layout } from '../Layout';\nimport { getPixiSize } from '../utils/getPixiSize';\nimport { type LayoutStyles } from './layoutStyles';\nimport { type YogaStyles } from './yogaStyles';\n\n/**\n * Formats the layout styles for the layout\n * @param layout - The layout to format the styles for\n * @param style - The style to apply to the layout\n */\nexport function formatStyles(layout: Layout, style: LayoutStyles) {\n    const currentStyles = layout._styles;\n    let customStyles = { ...currentStyles.custom, ...style };\n    const defaultStyle = {\n        ...Layout.defaultStyle.shared,\n        ...(layout.target instanceof ViewContainer || customStyles.isLeaf || Layout.defaultStyle.shared.isLeaf\n            ? Layout.defaultStyle.leaf\n            : Layout.defaultStyle.container),\n    };\n\n    customStyles = { ...defaultStyle, ...customStyles };\n    const yogaStyles = { ...(customStyles as YogaStyles) };\n\n    const widthIntrinsic = customStyles.width === 'intrinsic';\n    const heightIntrinsic = customStyles.height === 'intrinsic';\n\n    if (widthIntrinsic || heightIntrinsic) {\n        const { width, height } = getPixiSize(layout);\n\n        if (widthIntrinsic) {\n            yogaStyles.width = width;\n        }\n        if (heightIntrinsic) {\n            yogaStyles.height = height;\n        }\n    }\n\n    return { custom: customStyles, yoga: yogaStyles };\n}\n", "import { type Container } from 'pixi.js';\nimport { type OverflowContainer } from '../../components/LayoutContainer';\nimport { type Layout } from '../Layout';\n\n/**\n * Sorts the children of the layout based on their order in the parent container\n * This is necessary because not all children are part of the layout and we need to\n * make sure that the Yoga children are in the correct order\n * @param layout - The layout to sort the children for\n */\nexport function onChildAdded(layout: Layout, pixiParent: Container) {\n    let parentLayout = pixiParent.layout;\n    let yogaIndex = -1;\n\n    if (!parentLayout && (pixiParent as OverflowContainer).isOverflowContainer) {\n        parentLayout = pixiParent.parent?.layout;\n        // update yogaIndex\n        yogaIndex = pixiParent.children.indexOf(layout.target);\n        pixiParent = pixiParent.parent!;\n    }\n\n    if (parentLayout) {\n        const yogaParent = layout.yoga.getParent();\n\n        if (yogaParent) {\n            yogaParent!.removeChild(layout.yoga);\n        }\n\n        // If the child is the last one, we can just append it\n        if (pixiParent.children.indexOf(layout.target) === pixiParent.children.length - 1 && yogaIndex === -1) {\n            parentLayout.yoga.insertChild(layout.yoga, parentLayout.yoga.getChildCount());\n\n            return;\n        }\n\n        // Find the corresponding Yoga index\n        for (let i = 0; i < pixiParent.children.length; i++) {\n            const child = pixiParent.children[i]!;\n\n            if (child.layout && child.visible) {\n                yogaIndex++;\n            }\n            if (child === layout.target) {\n                break;\n            }\n        }\n        parentLayout.yoga.insertChild(layout.yoga, yogaIndex);\n    }\n}\n\n/**\n * Removes the child from the layout\n * @param layout - The layout to remove the child from\n */\nexport function onChildRemoved(layout: Layout) {\n    const yogaParent = layout.yoga.getParent();\n\n    yogaParent && yogaParent!.removeChild(layout.yoga);\n}\n", "import { type Container } from 'pixi.js';\nimport { type Node } from 'yoga-layout';\nimport { type OverflowContainer } from '../components/LayoutContainer';\nimport { getYoga } from '../yoga';\nimport { applyStyle } from './style/applyStyle';\nimport { formatStyles } from './style/formatStyles';\nimport { type LayoutStyles } from './style/layoutStyles';\nimport { type ComputedLayout, type ComputedPixiLayout, type InternalStyles } from './types';\nimport { onChildAdded, onChildRemoved } from './utils/sort-children';\n\nexport interface LayoutOptions extends LayoutStyles {\n    target: Container;\n}\n\n/**\n * Main Layout class that handles the combination of PixiJS containers and their layout\n * using the Yoga layout engine\n */\nexport class Layout {\n    /** Default style values to apply to the layout */\n    public static defaultStyle: { container: LayoutStyles; leaf: LayoutStyles; shared: LayoutStyles } = {\n        leaf: {\n            width: 'intrinsic',\n            height: 'intrinsic',\n        },\n        container: {\n            width: 'auto',\n            height: 'auto',\n        },\n        shared: {\n            transformOrigin: '50%',\n            objectPosition: 'center',\n            flexShrink: 1,\n            flexDirection: 'row',\n            alignContent: 'stretch',\n            flexWrap: 'nowrap',\n            overflow: 'visible',\n        },\n    };\n    /** The Yoga node instance for this layout */\n    public yoga: Readonly<Node>;\n    /** The target PixiJS container */\n    public readonly target: Container;\n\n    /**\n     * Flag indicating if layout needs recalculation\n     * @ignore\n     */\n    public _isDirty = false;\n\n    /**\n     * The computed pixi layout that is applied to the target container in the updateLocalTransform step\n     * @ignore\n     */\n    public _computedPixiLayout: Required<ComputedPixiLayout> = {\n        /** The left value of the view */\n        x: 0,\n        /** The top value of the view */\n        y: 0,\n        /** The offset x value of the view within its box */\n        offsetX: 0,\n        /** The offset y value of the view within its box */\n        offsetY: 0,\n        /** The scale x value of the view within its box */\n        scaleX: 1,\n        /** The scale y value of the view within its box */\n        scaleY: 1,\n        /** The x origin of the view */\n        originX: 0,\n        /** The y origin of the view */\n        originY: 0,\n    };\n\n    /**\n     * The computed bounds of the yoga node\n     * @ignore\n     */\n    public _computedLayout: ComputedLayout = {\n        /** The left value of the view */\n        left: 0,\n        /** The right value of the view */\n        right: 0,\n        /** The top value of the view */\n        top: 0,\n        /** The bottom value of the view */\n        bottom: 0,\n        /** The width of the view */\n        width: 0,\n        /** The height of the view */\n        height: 0,\n    };\n\n    /**\n     * The styles used for layout calculation\n     * @ignore\n     */\n    public _styles: InternalStyles = {\n        custom: {},\n        yoga: {},\n    };\n\n    /**\n     * The number of times the layout has been modified\n     * @ignore\n     */\n    public _modificationCount = 0;\n\n    /**\n     * Flag indicating if the layout should be recalculated even if it hasn't changed the yoga node.\n     * This is used to force an update when certain style properties change such as `objectFit`.\n     * @ignore\n     */\n    public _forceUpdate = false;\n\n    /**\n     * Flag indicating if the layout has a parent node\n     */\n    public hasParent = false;\n\n    /**\n     * The keys to track for changes to force an update\n     * @ignore\n     */\n    protected _trackedStyleKeys: (keyof LayoutStyles)[] = [\n        'borderRadius',\n        'borderColor',\n        'backgroundColor',\n        'objectFit',\n        'objectPosition',\n        'transformOrigin',\n        'isLeaf',\n    ];\n\n    constructor({ target }: LayoutOptions) {\n        this.target = target;\n        this.yoga = getYoga().Node.create();\n\n        target.on('added', this._onChildAdded, this);\n        target.on('removed', this._onChildRemoved, this);\n        target.on('destroyed', this.destroy, this);\n    }\n\n    /** Returns the layout style */\n    public get style(): Readonly<LayoutStyles> {\n        return this._styles.custom;\n    }\n\n    /** Returns the computed layout of the yoga node */\n    public get computedLayout(): Readonly<ComputedLayout> {\n        return this._computedLayout;\n    }\n\n    /** Returns the computed layout of the pixi node */\n    public get computedPixiLayout(): Readonly<Required<ComputedPixiLayout>> {\n        return this._computedPixiLayout;\n    }\n\n    /**\n     * Returns the true x position of the target.\n     *\n     * When an element is in layout, the x/y position is an offset from where it is laid out.\n     * This is the true x position of the element in the parent container.\n     */\n    public get realX() {\n        return this.target.localTransform.tx;\n    }\n    /**\n     * Returns the true y position of the target.\n     *\n     * When an element is in layout, the x/y position is an offset from where it is laid out.\n     * This is the true y position of the element in the parent container.\n     */\n    public get realY() {\n        return this.target.localTransform.ty;\n    }\n    /**\n     * Returns the true x scale of the target.\n     *\n     * When an element is in layout, the scale is an offset from 1.\n     * This is the true x scale of the element.\n     */\n    public get realScaleX() {\n        return this.target.localTransform.a;\n    }\n    /**\n     * Returns the true y scale of the target.\n     *\n     * When an element is in layout, the scale is an offset from 1.\n     * This is the true y scale of the element.\n     */\n    public get realScaleY() {\n        return this.target.localTransform.d;\n    }\n\n    /**\n     * Updates the layout style and triggers recalculation\n     * @param style - New layout style to apply\n     */\n    public setStyle(style: LayoutStyles): void {\n        const styles = formatStyles(this, style);\n        const differentCustom = JSON.stringify(this._styles.custom) !== JSON.stringify(styles.custom);\n        const differentYoga = JSON.stringify(this._styles.yoga) !== JSON.stringify(styles.yoga);\n        const different = differentCustom || differentYoga;\n        // Check if any tracked style keys have changed\n        const hasTrackedChanges = this._trackedStyleKeys.some((key) => styles.custom[key] !== this._styles.custom[key]);\n\n        this._styles = styles;\n\n        if (hasTrackedChanges) {\n            this._forceUpdate = true;\n        }\n\n        if (different) {\n            applyStyle(this.yoga, this._styles.yoga);\n            this.target._onUpdate();\n            this.invalidateRoot();\n        }\n    }\n\n    /** Marks the root layout as needing recalculation */\n    public invalidateRoot(): void {\n        const root = this.getRoot();\n\n        root._layout!._isDirty = true;\n        root._onUpdate();\n\n        this._modificationCount++;\n    }\n\n    /**\n     * Forces an update of the layout even if it hasn't changed the yoga node.\n     * This is used to force an update when certain style properties change such as `objectFit`.\n     * Or when you have changed something inside of Pixi that is not tracked by the layout system.\n     */\n    public forceUpdate(): void {\n        this._forceUpdate = true;\n    }\n\n    /**\n     * Finds the root container by traversing up the layout tree\n     * @returns The root container\n     */\n    public getRoot(): Container {\n        // find the root node by traversing up the yoga tree\n        let root: Container = this.target as Container;\n\n        while (root.parent?._layout || (root.parent as OverflowContainer)?.isOverflowContainer) {\n            root = root.parent;\n\n            if ((root as OverflowContainer).isOverflowContainer) {\n                root = root.parent!;\n            }\n        }\n\n        return root;\n    }\n\n    /**\n     * @ignore\n     */\n    public _onChildAdded(pixiParent: Container): void {\n        if (this.hasParent) return;\n\n        this.hasParent = true;\n        this.invalidateRoot();\n        onChildAdded(this, pixiParent);\n    }\n\n    /**\n     * @ignore\n     */\n    public _onChildRemoved(): void {\n        if (!this.hasParent) return;\n\n        this.hasParent = false;\n        this.invalidateRoot();\n        onChildRemoved(this);\n    }\n\n    public destroy(): void {\n        this.invalidateRoot();\n        this.yoga.free();\n        this.target.off('added', this._onChildAdded, this);\n        this.target.off('removed', this._onChildRemoved, this);\n        this._styles = null!;\n        this._computedPixiLayout = null!;\n        this._computedLayout = null!;\n        (this as any).target = null!;\n        this.hasParent = false;\n    }\n}\n", "import { type Bounds } from 'pixi.js';\nimport { type LayoutStyles } from '../../style/layoutStyles';\nimport { type ComputedLayout } from '../../types';\n\n/**\n * Calculates scaling factors for content based on CSS object-fit rules\n * Determines how content should be resized to fit within its container\n *\n * @param value - The object-fit mode to apply ('fill', 'contain', 'cover', 'none', 'scale-down')\n * @param computedLayout - The computed layout dimensions from Yoga\n * @param bounds - The original bounds of the content being sized\n * @returns Object containing x and y scaling factors to apply\n */\nexport function calculateObjectFit(value: LayoutStyles['objectFit'], computedLayout: ComputedLayout, bounds: Bounds) {\n    let offsetScaleX: number = 1;\n    let offsetScaleY: number = 1;\n\n    switch (value) {\n        case 'fill':\n            // Stretch to fill target dimensions\n            offsetScaleX = computedLayout.width / bounds.width;\n            offsetScaleY = computedLayout.height / bounds.height;\n            break;\n\n        case 'contain': {\n            // Scale to fit while maintaining aspect ratio\n            const scaleContain = Math.min(computedLayout.width / bounds.width, computedLayout.height / bounds.height);\n\n            offsetScaleX = scaleContain;\n            offsetScaleY = scaleContain;\n            break;\n        }\n\n        case 'cover': {\n            // Scale to cover while maintaining aspect ratio\n            const scaleCover = Math.max(computedLayout.width / bounds.width, computedLayout.height / bounds.height);\n\n            offsetScaleX = scaleCover;\n            offsetScaleY = scaleCover;\n            break;\n        }\n\n        case 'none':\n            // Use original size\n            offsetScaleX = 1;\n            offsetScaleY = 1;\n            break;\n\n        case 'scale-down': {\n            // Like contain, but never scale up\n            const scaleDown = Math.min(1, computedLayout.width / bounds.width, computedLayout.height / bounds.height);\n\n            offsetScaleX = scaleDown;\n            offsetScaleY = scaleDown;\n            break;\n        }\n\n        default:\n            break;\n    }\n\n    return {\n        offsetScaleX,\n        offsetScaleY,\n    };\n}\n", "import { type Container, NineSliceSprite, type ObservablePoint, TilingSprite, type ViewContainer } from 'pixi.js';\nimport { type LayoutStyles } from '../../style/layoutStyles';\nimport { type ComputedLayout, type ComputedPixiLayout } from '../../types';\nimport { calculateObjectFit } from './calculateObjectFit';\nimport { calculatePositionSpecifier } from './calculatePositionSpecifier';\n\n/**\n * Calculates the final position and scale for a container based on its layout\n * Handles object-fit and object-position to determine how content is sized and positioned\n *\n * @param container - The container to calculate layout data for\n * @param computedLayout - The computed layout data from Yoga\n * @param defaultObjectFit - Default object-fit value to use if none specified\n * @param anchor - Optional anchor point for positioning adjustments\n * @returns The final position and scale values to apply\n */\n\nexport function baseComputeLayoutData(\n    container: Container | ViewContainer,\n    computedLayout: ComputedLayout,\n    defaultObjectFit: LayoutStyles['objectFit'],\n    anchor?: ObservablePoint,\n): ComputedPixiLayout {\n    const bounds = container.getLocalBounds();\n\n    const objectFit = container.layout!.style.objectFit || defaultObjectFit;\n    let { offsetScaleX, offsetScaleY } = calculateObjectFit(objectFit, computedLayout, bounds);\n\n    // scale the current bounds by the offset scale\n    const scaledBounds = {\n        width: bounds.width * offsetScaleX,\n        height: bounds.height * offsetScaleY,\n    };\n    let { x: offsetX, y: offsetY } = calculatePositionSpecifier(\n        container.layout!.style.objectPosition,\n        computedLayout,\n        scaledBounds,\n    );\n\n    // offset the anchor point if it exists, otherwise offset by the minX and minY to account for containers with negative x/y\n    if (anchor) {\n        offsetX += bounds.width * offsetScaleX * anchor._x;\n        offsetY += bounds.height * offsetScaleY * anchor._y;\n    } else {\n        offsetX -= bounds.minX * offsetScaleX;\n        offsetY -= bounds.minY * offsetScaleY;\n    }\n\n    const applySizeDirectly = container.layout!.style.applySizeDirectly;\n\n    // If applySizeDirectly is true, set the container's width and height directly\n    if (\n        applySizeDirectly === true ||\n        // eslint-disable-next-line eqeqeq\n        (applySizeDirectly == undefined && (container instanceof TilingSprite || container instanceof NineSliceSprite))\n    ) {\n        container.width = bounds.width * offsetScaleX;\n        container.height = bounds.height * offsetScaleY;\n        offsetScaleX = 1;\n        offsetScaleY = 1;\n    }\n\n    return {\n        x: computedLayout.left,\n        y: computedLayout.top,\n        offsetX,\n        offsetY,\n        scaleX: offsetScaleX,\n        scaleY: offsetScaleY,\n    };\n}\n", "import { Container, extensions } from 'pixi.js';\nimport { Layout, type LayoutOptions } from '../Layout';\nimport { type ComputedLayout } from '../types';\nimport { baseComputeLayoutData } from './utils/baseComputeLayoutData';\n\n/**\n * Extended interface for Container with private properties needed for layout\n * Provides type safety for internal properties we need to access\n */\ninterface PrivateContainer extends Omit<Container, '_didLocalTransformChangeId'> {\n    _didLocalTransformChangeId: number;\n}\n\nconst visibility = Object.getOwnPropertyDescriptor(Container.prototype, 'visible')!;\n\nconst mixin: Partial<PrivateContainer> = {\n    // Internal reference to the layout object\n    _layout: null,\n\n    /**\n     * Gets the current layout associated with this container\n     * @returns The container's layout or null if no layout is attached\n     */\n    get layout(): Layout | null {\n        return this._layout ?? null;\n    },\n\n    /**\n     * Sets the layout for this container\n     * @param value - Layout options to apply, or null to remove layout\n     */\n    set layout(value: Omit<LayoutOptions, 'target'> | null | boolean) {\n        // If the value is a boolean, we want to treat it as an empty object\n        value = value === true ? {} : value;\n\n        if (!value) {\n            if (this._layout) {\n                this._layout.destroy();\n                this._layout = null;\n                this.updateLocalTransform = Container.prototype.updateLocalTransform;\n                Object.defineProperty(Container.prototype, 'visible', visibility);\n            }\n\n            return;\n        }\n\n        if (!this._layout) {\n            this._layout = new Layout({ target: this as unknown as Container });\n\n            // eslint-disable-next-line accessor-pairs\n            Object.defineProperty(Container.prototype, 'visible', {\n                ...visibility,\n                set(visibleValue: boolean) {\n                    visibility.set!.call(this, visibleValue);\n                    if (this.layout) {\n                        if (visibleValue && this.parent) {\n                            this.layout._onChildAdded(this.parent);\n                        } else {\n                            this.layout._onChildRemoved();\n                        }\n                    }\n                },\n            });\n            if (this.parent && this.visible) {\n                this._layout._onChildAdded(this.parent);\n            }\n        }\n\n        this._layout.setStyle(value);\n\n        this.updateLocalTransform = this.updateLocalTransformWithLayout;\n        this._onUpdate!();\n    },\n\n    /**\n     * This function overrides how we calculate the local transform of the container.\n     * For the layout, we need to not only calculate the transform matrix, but also\n     * take into account the yoga layout's position and scale.\n     */\n    updateLocalTransformWithLayout() {\n        const localTransformChangeId = this._didContainerChangeTick;\n        // early out if nothing has changed\n\n        if (this._didLocalTransformChangeId === localTransformChangeId) return;\n        this._didLocalTransformChangeId = localTransformChangeId;\n\n        const layout = this._layout!;\n\n        // this will return the position and scale offsets we should add to the local matrix\n        const { x, y, offsetX, offsetY, scaleX, scaleY, originX, originY } = layout._computedPixiLayout!;\n\n        // if this is a leaf node then we must pretend that the leaf is inside of a container\n        // this allows use to define the \"box\" that the leaf is inside of\n        // and then apply the transform to the container instead of the leaf\n        // we then apply the additional transforms to the leaf to push it around inside of its box\n        // this effectively splits the transform into two parts\n        const lt = this.localTransform;\n        const { rotation, skew, scale, position } = this;\n\n        // Precompute trig values\n        const xRotY = rotation + skew._y;\n        const xRotX = rotation - skew._x;\n\n        const a = Math.cos(xRotY) * scale._x;\n        const b = Math.sin(xRotY) * scale._x;\n        const c = -Math.sin(xRotX) * scale._y;\n        const d = Math.cos(xRotX) * scale._y;\n\n        // Apply offset, origin and position in one step\n        const tx = position._x + x - originX * a - originY * c;\n        const ty = position._y + y - originX * b - originY * d;\n\n        // Apply additional static transform and re-add origin\n        lt.a = a * scaleX;\n        lt.b = b * scaleX;\n        lt.c = c * scaleY;\n        lt.d = d * scaleY;\n        lt.tx = tx + (offsetX * a + offsetY * c) + originX;\n        lt.ty = ty + (offsetX * b + offsetY * d) + originY;\n    },\n\n    /**\n     * Apply the computed layout to the container\n     * Converts Yoga layout information into PixiJS positioning\n     * @param computedLayout - Layout data from Yoga engine\n     * @returns Transformed position and scale data for this container\n     * @memberof scene.Container#\n     */\n    computeLayoutData(computedLayout: ComputedLayout) {\n        const layout = this._layout!;\n        const { isLeaf } = layout._styles.custom;\n\n        if (isLeaf) {\n            return baseComputeLayoutData(this as unknown as Container, computedLayout, 'fill');\n        }\n\n        return {\n            x: computedLayout.left,\n            y: computedLayout.top,\n            offsetX: 0,\n            offsetY: 0,\n            scaleX: 1,\n            scaleY: 1,\n        };\n    },\n} as PrivateContainer;\n\nextensions.mixin(Container, mixin);\n", "import { AbstractText, extensions, Point, type TextString } from 'pixi.js';\nimport { type ComputedLayout } from '../types';\nimport { calculateObjectFit } from './utils/calculateObjectFit';\nimport { calculatePositionSpecifier } from './utils/calculatePositionSpecifier';\n\nconst tempScale = new Point(0, 0);\nconst mixin: Partial<AbstractText> = {\n    /**\n     * Computes the layout data for the text element\n     * @param computedLayout - The computed layout from Yoga\n     * @returns The layout data for the text element\n     */\n    computeLayoutData(computedLayout: ComputedLayout) {\n        const style = this._style!;\n\n        tempScale.copyFrom(this.scale);\n        this.scale = 1;\n\n        if (style.wordWrap) {\n            // we want to scale down the text first then wrap it\n            style.wordWrapWidth = computedLayout.width;\n        }\n\n        let bounds = this.getLocalBounds();\n\n        const objectFit = this.layout!.style.objectFit || 'scale-down';\n        const { offsetScaleX, offsetScaleY } = calculateObjectFit(objectFit, computedLayout, bounds);\n\n        if (style.wordWrap) {\n            // we now need to recalculate the wordWrapWidth based on the new scale\n            style.wordWrapWidth = computedLayout.width / Math.min(1, Math.max(offsetScaleX, offsetScaleY));\n        }\n\n        // recalculate the bounds after the wordWrapWidth has been set\n        bounds = this.getLocalBounds();\n\n        // scale the current bounds by the offset scale\n        const scaledBounds = {\n            width: bounds.width * offsetScaleX,\n            height: bounds.height * offsetScaleY,\n        };\n        let { x: offsetX, y: offsetY } = calculatePositionSpecifier(\n            this.layout!.style.objectPosition,\n            computedLayout,\n            scaledBounds,\n        );\n\n        // offset the anchor point\n        offsetX += bounds.width * offsetScaleX * this.anchor._x;\n        offsetY += bounds.height * offsetScaleY * this.anchor._y;\n\n        const applySizeDirectly = this.layout!.style.applySizeDirectly;\n\n        // If applySizeDirectly is true, set the this's width and height directly\n        if (applySizeDirectly === true) {\n            this.width = bounds.width * offsetScaleX;\n            this.height = bounds.height * offsetScaleY;\n        }\n\n        // Reset the scale to the original value\n        this.scale.copyFrom(tempScale);\n\n        return {\n            x: computedLayout.left,\n            y: computedLayout.top,\n            offsetX,\n            offsetY,\n            scaleX: offsetScaleX,\n            scaleY: offsetScaleY,\n        };\n    },\n} as AbstractText;\n\nextensions.mixin(AbstractText, mixin);\n\nconst text = Object.getOwnPropertyDescriptor(AbstractText.prototype, 'text')!;\n\n// eslint-disable-next-line accessor-pairs\nObject.defineProperty(AbstractText.prototype, 'text', {\n    ...text,\n    set(textString: TextString) {\n        const currentText = text.get!.call(this);\n\n        text.set!.call(this, textString);\n\n        if (currentText === textString) return;\n        this.layout?.forceUpdate();\n    },\n});\n", "import { extensions, type ObservablePoint, ViewContainer } from 'pixi.js';\nimport { type ComputedLayout } from '../types';\nimport { baseComputeLayoutData } from './utils/baseComputeLayoutData';\n\nconst mixin: Partial<ViewContainer> = {\n    /**\n     * Computes the layout data for the container\n     * @param computedLayout - The computed layout from Yoga\n     * @returns The layout data for the container\n     */\n    computeLayoutData(computedLayout: ComputedLayout) {\n        return baseComputeLayoutData(this, computedLayout, 'fill', this._anchor);\n    },\n} as ViewContainer & { _anchor?: ObservablePoint };\n\nextensions.mixin(ViewContainer, mixin);\n", "import { extensions } from 'pixi.js';\nimport { LayoutSystem } from './core/LayoutSystem';\nimport './core/mixins/ContainerMixin';\nimport './core/mixins/TextMixin';\nimport './core/mixins/ViewContainerMixin';\n\n// layout\nexport * from './core/debug/DebugRenderer';\nexport * from './core/Layout';\nexport * from './core/LayoutSystem';\n// layout utils\nexport * from './core/style/applyStyle';\nexport * from './core/style/formatStyles';\nexport * from './core/utils/getNumberFromStyle';\nexport * from './core/utils/getPixiSize';\nexport * from './core/utils/nearlyEqual';\nexport * from './core/utils/sort-children';\n// types\nexport * from './core/style/layoutStyles';\nexport * from './core/style/yogaStyles';\nexport * from './core/types';\n// misc\nexport * from './yoga';\n\ndeclare global {\n    // eslint-disable-next-line @typescript-eslint/no-namespace\n    namespace PixiMixins {\n        interface Container {\n            _layout: import('./core/Layout').Layout | null;\n            get layout(): import('./core/Layout').Layout | null;\n            set layout(value: Omit<import('./core/Layout').LayoutOptions, 'target'> | null | boolean);\n            onLayout(value: import('./core/Layout').Layout): void;\n            computeLayoutData(\n                computedLayout: import('./core/types').ComputedLayout,\n            ): import('./core/types').ComputedPixiLayout;\n            updateLocalTransformWithLayout: () => void;\n        }\n\n        interface ContainerEvents {\n            layout: [event: import('./core/Layout').Layout];\n        }\n\n        interface ContainerOptions {\n            layout?: Omit<import('./core/Layout').LayoutOptions, 'target'> | null;\n        }\n\n        interface RendererSystems {\n            layout: import('./core/LayoutSystem').LayoutSystem;\n        }\n\n        interface RendererOptions {\n            layout?: import('./core/LayoutSystem').LayoutSystemOptions;\n        }\n    }\n}\n\nextensions.add(LayoutSystem);\n"],
  "mappings": "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",
  "names": ["throttle", "throttleFn", "__publicField", "TilingSprite", "NineSliceSprite", "position", "mixin", "mixin"]
}
