# backend/engine/state_machine/events/event_types.py

"""
Event type definitions for event-driven state machine

These classes define all event types that replace polling-based state transitions
with immediate event processing.
"""

import time
from dataclasses import dataclass, field
from typing import Dict, Any, Optional
from enum import Enum

from ..core import GamePhase, ActionType


@dataclass
class GameEvent:
    """Unified event structure for all state machine events"""
    
    event_type: str           # "user", "system", "timer", "state"
    trigger: str              # Specific event trigger (e.g., "play_pieces", "turn_complete")
    data: Dict[str, Any]      # Event payload
    player_name: Optional[str] = None
    timestamp: float = field(default_factory=time.time)
    immediate: bool = True    # True for logic events, False for display
    sequence_id: int = 0      # For event ordering
    
    @classmethod
    def from_action(cls, action, immediate: bool = True) -> "GameEvent":
        """Create event from GameAction"""
        return cls(
            event_type="user",
            trigger=action.action_type.value,
            data=action.payload,
            player_name=action.player_name,
            immediate=immediate
        )


@dataclass
class EventResult:
    """Result of event processing"""
    
    success: bool
    triggers_transition: bool = False
    target_state: Optional[GamePhase] = None
    transition_trigger: str = ""
    reason: str = ""
    data: Dict[str, Any] = field(default_factory=dict)
    transition_completed: bool = False


class UserEvent:
    """Events triggered by direct user actions"""
    
    PLAY_PIECES = "play_pieces"        # Player selects pieces to play
    DECLARE = "declare"                # Player declares pile count
    REDEAL_REQUEST = "redeal_request"  # Player requests redeal (weak hand)
    DISCONNECT = "disconnect"          # Player loses connection
    RECONNECT = "reconnect"           # Player reconnects
    CONTINUE_ROUND = "continue_round" # Manual advance from display phases
    SKIP_DISPLAY = "skip_display"     # User skips display timing


class SystemEvent:
    """Events generated by game logic"""
    
    # Turn-related events
    TURN_COMPLETE = "turn_complete"           # All players have played pieces
    TURN_WINNER_DETERMINED = "turn_winner"   # Winner calculation complete
    PIECES_TRANSFERRED = "pieces_transferred" # Winner takes all pieces
    
    # Round-related events  
    ROUND_COMPLETE = "round_complete"         # All hands empty
    ALL_DECLARED = "all_declared"             # All players declared
    
    # Game-related events
    GAME_COMPLETE = "game_complete"           # Win condition met
    ALL_HANDS_EMPTY = "all_hands_empty"       # No more pieces to play
    WIN_CONDITION_MET = "win_condition_met"   # Player reached 50+ points
    
    # Setup events
    CARDS_DEALT = "cards_dealt"               # Initial deal complete
    WEAK_HANDS_RESOLVED = "weak_hands_resolved" # All redeal decisions made
    SCORES_CALCULATED = "scores_calculated"   # Round scoring complete
    
    # Validation events
    VALID_PLAY_CONFIRMED = "valid_play_confirmed"     # Play validated by rules
    INVALID_PLAY_DETECTED = "invalid_play_detected"   # Rule violation found


class TimerEvent:
    """Events for UI timing only - NO LOGIC IMPACT"""
    
    DISPLAY_DELAY_COMPLETE = "display_delay_complete"  # Display timing finished
    UI_ANIMATION_COMPLETE = "ui_animation_complete"    # Frontend animation done
    AUTO_ADVANCE_READY = "auto_advance_ready"          # UI ready for next phase
    
    # Specific display phases
    TURN_RESULTS_DISPLAY_COMPLETE = "turn_results_display_complete"   # 7s turn display
    SCORING_DISPLAY_COMPLETE = "scoring_display_complete"             # 7s scoring display
    CARD_DEAL_ANIMATION_COMPLETE = "card_deal_animation_complete"     # Deal animation
    PIECE_MOVE_ANIMATION_COMPLETE = "piece_move_animation_complete"   # Piece animations
    
    # User experience events  
    NOTIFICATION_DISMISSED = "notification_dismissed"   # User dismissed notification
    TUTORIAL_STEP_COMPLETE = "tutorial_step_complete"   # Tutorial progression


class StateEvent:
    """Events for state machine lifecycle"""
    
    # State lifecycle events
    PHASE_ENTERED = "phase_entered"           # State setup complete
    PHASE_EXITING = "phase_exiting"          # State cleanup starting
    TRANSITION_READY = "transition_ready"     # Ready for state change
    SETUP_COMPLETE = "setup_complete"        # State initialization done
    CLEANUP_COMPLETE = "cleanup_complete"    # State cleanup finished
    
    # State validation events
    TRANSITION_VALIDATED = "transition_validated"     # Transition conditions met
    TRANSITION_BLOCKED = "transition_blocked"         # Invalid transition attempted
    STATE_SYNC_REQUIRED = "state_sync_required"       # State needs synchronization
    
    # Task management events
    ASYNC_TASK_STARTED = "async_task_started"         # Background task initiated
    ASYNC_TASK_COMPLETED = "async_task_completed"     # Background task finished
    ASYNC_TASK_CANCELLED = "async_task_cancelled"     # Task cancelled during cleanup
    
    # Error handling events
    STATE_ERROR = "state_error"                       # State processing error
    RECOVERY_INITIATED = "recovery_initiated"         # Error recovery started
    STATE_CORRUPTED = "state_corrupted"               # State inconsistency detected


# Event type collections for validation
LOGIC_EVENTS = {
    UserEvent.PLAY_PIECES,
    UserEvent.DECLARE,
    UserEvent.REDEAL_REQUEST,
    SystemEvent.TURN_COMPLETE,
    SystemEvent.ALL_DECLARED,
    SystemEvent.ROUND_COMPLETE,
    SystemEvent.SCORES_CALCULATED,
    SystemEvent.GAME_COMPLETE
}

DISPLAY_EVENTS = {
    TimerEvent.DISPLAY_DELAY_COMPLETE,
    TimerEvent.UI_ANIMATION_COMPLETE,
    TimerEvent.AUTO_ADVANCE_READY,
    TimerEvent.TURN_RESULTS_DISPLAY_COMPLETE,
    TimerEvent.SCORING_DISPLAY_COMPLETE
}

def is_logic_event(trigger: str) -> bool:
    """Check if event trigger affects game logic"""
    return trigger in LOGIC_EVENTS

def is_display_event(trigger: str) -> bool:
    """Check if event trigger is display-only"""
    return trigger in DISPLAY_EVENTS