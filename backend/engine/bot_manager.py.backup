# backend/engine/bot_manager.py

import asyncio
from typing import Dict, List, Optional
import logging

logger = logging.getLogger(__name__)

class PhaseAwareBotManager:
    """
    Bot manager that respects phase boundaries and only acts during appropriate phases
    """
    
    def __init__(self):
        self.active_bots: Dict[str, Dict] = {}  # room_id -> bot_data
        self.phase_handlers = {
            "waiting": self._handle_waiting_phase,
            "redeal": self._handle_redeal_phase,
            "declaration": self._handle_declaration_phase,
            "turn": self._handle_turn_phase,
            "scoring": self._handle_scoring_phase,
        }
        self.pending_actions: Dict[str, List] = {}  # room_id -> actions
        
    async def register_room(self, room_id: str, bot_players: List[str]):
        """Register bots for a room"""
        self.active_bots[room_id] = {
            "bots": bot_players,
            "current_phase": "waiting",
            "phase_data": {},
            "action_timers": {},
        }
        self.pending_actions[room_id] = []
        logger.info(f"Registered {len(bot_players)} bots for room {room_id}")
    
    async def handle_phase_change(self, room_id: str, new_phase: str, phase_data: Dict = None):
        """Handle phase transitions for bot behavior"""
        if room_id not in self.bot_rooms:
            return
        
        logger.info(f"Bots in room {room_id} notified of phase: {new_phase}")
        
        # Cancel any pending bot actions
        if room_id in self.pending_actions:
            for task in self.pending_actions[room_id]:
                task.cancel()
            self.pending_actions[room_id].clear()
        
        # Schedule phase-appropriate bot actions
        if new_phase == "declaration":
            await self._schedule_bot_declarations(room_id, phase_data)
        elif new_phase == "turn":
            await self._schedule_bot_turns(room_id, phase_data)
        # Don't schedule anything for redeal phase - wait for prompts
    
    # ==================== PHASE HANDLERS ====================
    
    async def _handle_waiting_phase(self, room_id: str, phase_data: Dict):
        """Handle waiting phase - bots do nothing"""
        logger.info(f"Bots in {room_id}: Waiting phase, no actions needed")
    
    async def _handle_redeal_phase(self, room_id: str, phase_data: Dict):
        """Handle redeal phase - bots respond to redeal prompts"""
        room_data = self.active_bots[room_id]
        
        # Bots wait for redeal prompts, don't act immediately
        logger.info(f"Bots in {room_id}: Redeal phase started, waiting for prompts")
        
        # Set up redeal decision logic
        room_data["redeal_strategy"] = self._get_redeal_strategy()
    
    async def _handle_declaration_phase(self, room_id: str, phase_data: Dict):
        """Handle declaration phase - bots declare in turn order"""
        room_data = self.active_bots[room_id]
        
        # Important: Add delay to ensure phase transition is complete
        await asyncio.sleep(0.5)
        
        # Get declaration order if provided
        declaration_order = phase_data.get("declaration_order", [])
        
        for bot_name in room_data["bots"]:
            if bot_name in declaration_order:
                # Calculate delay based on position
                position = declaration_order.index(bot_name)
                delay = 1.0 + (position * 1.5)  # Stagger declarations
                
                # Schedule declaration
                asyncio.create_task(
                    self._delayed_bot_action(
                        room_id, bot_name, "declare", delay
                    )
                )
        
        logger.info(f"Bots in {room_id}: Scheduled declarations for declaration phase")
    
    async def _handle_turn_phase(self, room_id: str, phase_data: Dict):
        """Handle turn phase - bots play when it's their turn"""
        room_data = self.active_bots[room_id]
        
        # Bots will respond to turn prompts
        logger.info(f"Bots in {room_id}: Turn phase started, waiting for turn prompts")
        
        # Set up turn strategy
        room_data["turn_strategy"] = self._get_turn_strategy()
    
    async def _handle_scoring_phase(self, room_id: str, phase_data: Dict):
        """Handle scoring phase - bots wait for results"""
        logger.info(f"Bots in {room_id}: Scoring phase, no actions needed")
    
    # ==================== BOT ACTIONS ====================
    
    async def handle_redeal_prompt(self, room_id: str, bot_name: str, prompt_data: Dict):
        """Handle redeal prompt for a specific bot"""
        if not self._validate_bot_action(room_id, bot_name, "redeal"):
            return
        
        room_data = self.active_bots[room_id]
        strategy = room_data.get("redeal_strategy", "conservative")
        
        # Simulate thinking time
        await asyncio.sleep(random.uniform(1.0, 2.5))
        
        # Make decision based on strategy
        if strategy == "aggressive":
            choice = "accept" if random.random() < 0.8 else "decline"
        elif strategy == "conservative":
            choice = "decline" if random.random() < 0.7 else "accept"
        else:
            choice = random.choice(["accept", "decline"])
        
        logger.info(f"Bot {bot_name} chose to {choice} redeal")
        
        return {
            "action": "redeal_decision",
            "player": bot_name,
            "choice": choice,
            "timestamp": time.time(),
        }
    
    async def handle_declaration_turn(self, room_id: str, bot_name: str, game_state: Dict):
        """Handle declaration for a specific bot"""
        if not self._validate_bot_action(room_id, bot_name, "declaration"):
            return
        
        # Get valid options from game state
        valid_options = game_state.get("valid_options", list(range(9)))
        is_last_player = game_state.get("is_last_player", False)
        
        # Bot declaration strategy
        if is_last_player:
            # Last player must avoid sum of 8
            current_sum = sum(game_state.get("declarations", {}).values())
            valid_options = [opt for opt in valid_options if current_sum + opt != 8]
        
        # Choose based on bot personality
        declaration = self._choose_declaration(bot_name, valid_options)
        
        logger.info(f"Bot {bot_name} declares {declaration}")
        
        return {
            "action": "declare",
            "player": bot_name,
            "value": declaration,
            "is_bot": True,
            "timestamp": time.time(),
        }
    
    async def handle_turn_play(self, room_id: str, bot_name: str, turn_data: Dict):
        """Handle turn play for a specific bot"""
        if not self._validate_bot_action(room_id, bot_name, "turn"):
            return
        
        # Simulate thinking
        await asyncio.sleep(random.uniform(1.5, 3.0))
        
        hand = turn_data.get("hand", [])
        required_count = turn_data.get("required_count")
        is_first_player = turn_data.get("is_first_player", False)
        
        if is_first_player:
            # First player sets the count
            count = random.randint(1, min(6, len(hand)))
            pieces = random.sample(hand, count)
        else:
            # Must play required count
            if len(hand) >= required_count:
                pieces = random.sample(hand, required_count)
            else:
                pieces = hand  # Play all remaining
        
        logger.info(f"Bot {bot_name} plays {len(pieces)} pieces")
        
        return {
            "action": "play_pieces",
            "player": bot_name,
            "pieces": pieces,
            "is_bot": True,
            "timestamp": time.time(),
        }
    
    # ==================== UTILITY METHODS ====================
    
    async def validate_bot_action(self, room_id: str, bot_name: str, action: str) -> bool:
        """Validate if bot can perform action in current phase"""
        # Import inside function to avoid circular import
        from backend.engine.game_flow_controller import get_game_controller
        controller = get_game_controller(room_id)
        
        if controller:
            validation = controller.phase_manager.validate_action(action, {
                "player": bot_name,
                "is_bot": True
            })
            return validation["valid"]
        return False
    
    async def _delayed_bot_action(self, room_id: str, bot_name: str, action: str, delay: float):
        """Execute bot action after delay"""
        await asyncio.sleep(delay)
        
        # Revalidate phase after delay
        if room_id not in self.active_bots:
            return
        
        room_data = self.active_bots[room_id]
        
        if action == "declare" and room_data["current_phase"] == "declaration":
            # Trigger declaration through game logic
            logger.info(f"Bot {bot_name} executing delayed declaration")
            # Call your game's declaration handler here
    
    async def _cancel_pending_actions(self, room_id: str):
        """Cancel all pending actions for a room"""
        if room_id in self.active_bots:
            timers = self.active_bots[room_id].get("action_timers", {})
            for timer in timers.values():
                if timer and not timer.done():
                    timer.cancel()
            self.active_bots[room_id]["action_timers"] = {}
    
    def _get_redeal_strategy(self) -> str:
        """Get redeal strategy for bots"""
        return random.choice(["aggressive", "conservative", "balanced"])
    
    def _get_turn_strategy(self) -> str:
        """Get turn play strategy for bots"""
        return random.choice(["offensive", "defensive", "random"])
    
    def _choose_declaration(self, bot_name: str, valid_options: List[int]) -> int:
        """Choose declaration value based on bot personality"""
        if not valid_options:
            return 0
        
        # Simple personality based on name hash
        personality = hash(bot_name) % 3
        
        if personality == 0:  # Conservative
            return min(valid_options)
        elif personality == 1:  # Aggressive
            return max(valid_options)
        else:  # Balanced
            return valid_options[len(valid_options) // 2]
    
    def cleanup_room(self, room_id: str):
        """Clean up bot data for a room"""
        if room_id in self.active_bots:
            asyncio.create_task(self._cancel_pending_actions(room_id))
            del self.active_bots[room_id]
        
        if room_id in self.pending_actions:
            del self.pending_actions[room_id]
        
        logger.info(f"Cleaned up bot data for room {room_id}")

# Global bot manager instance
bot_manager = PhaseAwareBotManager()

class BotManager:
    """Centralized bot management system"""
    
    def __init__(self):
        self.active_games: Dict[str, GameBotHandler] = {}
        
    def register_game(self, room_id: str, game):
        """Register a game for bot management"""
        self.active_games[room_id] = GameBotHandler(room_id, game)
        
    def unregister_game(self, room_id: str):
        """Remove game from bot management"""
        if room_id in self.active_games:
            del self.active_games[room_id]
            
    async def handle_game_event(self, room_id: str, event: str, data: dict):
        """Handle game events that might need bot actions"""
        print(f"ðŸ”” Bot Manager: Received event '{event}' for room {room_id} with data: {data}")
        if room_id not in self.active_games:
            return
            
        handler = self.active_games[room_id]
        await handler.handle_event(event, data)


class GameBotHandler:
    """Handles bot actions for a specific game"""
    
    def __init__(self, room_id: str, game):
        self.room_id = room_id
        self.game = game
        self.processing = False
        self._lock = asyncio.Lock()
        
    async def handle_event(self, event: str, data: dict):
        """Process game events and trigger bot actions"""
        async with self._lock:  # Prevent concurrent bot actions
            if event == "player_declared":
                await self._handle_declaration_phase(data["player_name"])
            elif event == "player_played":
                await self._handle_play_phase(data["player_name"])
            elif event == "turn_started":
                await self._handle_turn_start(data["starter"])
            elif event == "round_started":
                await self._handle_round_start()
                
    async def _handle_declaration_phase(self, last_declarer: str):
        """Handle bot declarations in order"""
        from backend.socket_manager import broadcast
        
        # Get declaration order
        declaration_order = self._get_declaration_order()
        
        # Find next bot to declare
        last_index = self._get_player_index(last_declarer, declaration_order)
        
        for i in range(last_index + 1, len(declaration_order)):
            player = declaration_order[i]
            
            if not player.is_bot:
                break  # Wait for human player
                
            if player.declared != 0:
                continue  # Already declared
                
            # Bot declares
            await self._bot_declare(player, i)
            
            # Small delay for UI
            await asyncio.sleep(0.5)
            
    async def _bot_declare(self, bot: Player, position: int):
        """Make a bot declaration"""
        from backend.socket_manager import broadcast
        
        try:
            # Get previous declarations
            previous_declarations = [
                p.declared for p in self.game.players if p.declared != 0
            ]
            
            # Check if last player
            is_last = position == len(self.game.players) - 1
            
            # Calculate declaration
            value = ai.choose_declare(
                hand=bot.hand,
                is_first_player=(position == 0),
                position_in_order=position,
                previous_declarations=previous_declarations,
                must_declare_nonzero=(bot.zero_declares_in_a_row >= 2),
                verbose=False
            )
            
            # Apply last player rule
            if is_last:
                total_so_far = sum(p.declared for p in self.game.players if p.declared != 0)
                forbidden = 8 - total_so_far
                if value == forbidden and 0 <= forbidden <= 8:
                    print(f"âš ï¸ Bot {bot.name} cannot declare {value} (total would be 8)")
                    value = 1 if forbidden != 1 else 2
            
            # Apply declaration
            result = self.game.declare(bot.name, value)
            
            if result["status"] == "ok":
                # Broadcast to all clients
                await broadcast(self.room_id, "declare", {
                    "player": bot.name,
                    "value": value,
                    "is_bot": True
                })
                
                print(f"âœ… Bot {bot.name} declared {value}")
                
                # Check if more bots need to declare
                await self._handle_declaration_phase(bot.name)
                
        except Exception as e:
            print(f"âŒ Bot {bot.name} declaration error: {e}")
            import traceback
            traceback.print_exc()
            # Fallback declaration
            try:
                self.game.declare(bot.name, 1)
                await broadcast(self.room_id, "declare", {
                    "player": bot.name,
                    "value": 1,
                    "is_bot": True
                })
            except:
                pass
                
    async def _handle_round_start(self):
        """Handle start of a new round"""
        # Check if starter is a bot
        starter = self.game.current_order[0] if self.game.current_order else None
        if starter and starter.is_bot:
            print(f"ðŸ¤– Round starter is bot: {starter.name}")
            await asyncio.sleep(1)
            await self._handle_declaration_phase("")  # Empty string to start from beginning
            
    async def _handle_play_phase(self, last_player: str):
        """Handle bot plays in turn order"""
        from backend.socket_manager import broadcast
        
        if not self.game.required_piece_count:
            return  # First player hasn't set the count yet
            
        # Get current turn order
        turn_order = self.game.turn_order
        if not turn_order:
            return
            
        # Find next players to play
        last_index = self._get_player_index(last_player, turn_order)
        
        for i in range(last_index + 1, len(turn_order)):
            player = turn_order[i]
            
            # Check if already played this turn
            if any(play.player == player for play in self.game.current_turn_plays):
                continue
                
            if not player.is_bot:
                break  # Wait for human
                
            # Bot plays
            await self._bot_play(player)
            await asyncio.sleep(0.5)
            
    async def _bot_play(self, bot: Player):
        """Make a bot play"""
        from backend.socket_manager import broadcast
        
        try:
            # Choose play
            selected = ai.choose_best_play(
                bot.hand,
                required_count=self.game.required_piece_count,
                verbose=True
            )
            
            # Get indices
            indices = self._get_piece_indices(bot.hand, selected)
            
            # Make play
            result = self.game.play_turn(bot.name, indices)
            
            # Broadcast play
            await broadcast(self.room_id, "play", {
                "player": bot.name,
                "pieces": [str(p) for p in selected],
                "valid": result.get("is_valid", True),
                "play_type": result.get("play_type", "UNKNOWN")
            })
            
            # Handle turn resolution if complete
            if result.get("status") == "resolved":
                await self._handle_turn_resolved(result)
                
        except Exception as e:
            print(f"âŒ Bot {bot.name} play error: {e}")
            import traceback
            traceback.print_exc()
            
    async def _handle_turn_resolved(self, result: dict):
        """Handle end of turn"""
        from backend.socket_manager import broadcast
        
        await broadcast(self.room_id, "turn_resolved", {
            "plays": result["plays"],
            "winner": result["winner"],
            "pile_count": result["pile_count"]
        })
        
        # Check if round is complete
        if all(len(p.hand) == 0 for p in self.game.players):
            await self._handle_round_complete()
        elif result["winner"]:
            # Start next turn with winner
            await asyncio.sleep(0.5)
            await self._handle_turn_start(result["winner"])
            
    async def _handle_round_complete(self):
        """Handle round scoring"""
        from backend.socket_manager import broadcast
        from engine.win_conditions import is_game_over, get_winners
        
        summary = self.game.score_round()
        game_over = is_game_over(self.game)
        winners = get_winners(self.game) if game_over else []
        
        await broadcast(self.room_id, "score", {
            "summary": summary,
            "game_over": game_over,
            "winners": [p.name for p in winners]
        })
        
        if not game_over:
            # Start next round
            await asyncio.sleep(2)
            round_data = self.game.prepare_round()
            await broadcast(self.room_id, "start_round", {
                "round": round_data["round"],
                "starter": round_data["starter"],
                "hands": round_data["hands"],
                "players": [
                    {
                        "name": p.name,
                        "score": p.score,
                        "is_bot": p.is_bot,
                        "zero_declares_in_a_row": p.zero_declares_in_a_row
                    }
                    for p in self.game.players
                ]
            })
            await self._handle_round_start()
            
    async def _handle_turn_start(self, starter_name: str):
        """Handle start of a new turn"""
        print(f"ðŸŽ® Bot Manager: Handling turn start for {starter_name}")
        
        starter = self.game.get_player(starter_name)
        if not starter:
            print(f"âŒ Starter {starter_name} not found")
            return
            
        if starter.is_bot and len(starter.hand) > 0:
            print(f"ðŸ¤– Bot {starter_name} will play first")
            # Bot starts the turn
            await self._bot_play_first(starter)
        else:
            print(f"ðŸ‘¤ Human player {starter_name} starts, waiting for their play")
            
    async def _bot_play_first(self, bot: Player):
        """Bot plays as first player"""
        from backend.socket_manager import broadcast
        
        try:
            print(f"ðŸ¤– Bot {bot.name} choosing first play...")
            
            # Reset turn state
            self.game.current_turn_plays = []
            self.game.required_piece_count = None
            
            # Choose play
            selected = ai.choose_best_play(bot.hand, required_count=None, verbose=True)
            indices = self._get_piece_indices(bot.hand, selected)
            
            print(f"ðŸ¤– Bot {bot.name} will play {len(selected)} pieces: {[str(p) for p in selected]}")
            
            # Make the play
            result = self.game.play_turn(bot.name, indices)
            
            # Broadcast the play
            await broadcast(self.room_id, "play", {
                "player": bot.name,
                "pieces": [str(p) for p in selected],
                "valid": result.get("is_valid", True),
                "play_type": result.get("play_type", "UNKNOWN")
            })
            
            print(f"âœ… Bot {bot.name} played, status: {result.get('status')}")
            
            # If waiting for other players, trigger their plays
            if result.get("status") == "waiting":
                print(f"ðŸŽ¯ Waiting for other players to respond with {len(selected)} pieces")
                await asyncio.sleep(0.5)
                await self._handle_play_phase(bot.name)
                
        except Exception as e:
            print(f"âŒ Bot {bot.name} first play error: {e}")
            import traceback
            traceback.print_exc()
            
    def _get_declaration_order(self) -> List[Player]:
        """Get players in declaration order"""
        return self.game.current_order
        
    def _get_player_index(self, player_name: str, order: List[Player]) -> int:
        """Find player index in order"""
        for i, p in enumerate(order):
            if p.name == player_name:
                return i
        return -1
        
    def _get_piece_indices(self, hand: List, selected: List) -> List[int]:
        """Convert selected pieces to indices"""
        indices = []
        hand_copy = list(hand)
        for piece in selected:
            if piece in hand_copy:
                idx = hand_copy.index(piece)
                indices.append(idx)
                hand_copy[idx] = None  # Mark as used
        return indices
    
