<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>React Hooks Test</title>
    <style>
        body { font-family: monospace; padding: 20px; background: #1a1a1a; color: #00ff00; }
        .container { max-width: 1400px; margin: 0 auto; }
        .test-section { margin: 20px 0; padding: 15px; border: 1px solid #333; background: #222; }
        .hook-demo { margin: 15px 0; padding: 15px; border: 1px solid #444; background: #333; border-radius: 5px; }
        .test-result { margin: 10px 0; padding: 10px; border-radius: 4px; }
        .success { background: #2d5a2d; border: 1px solid #4a8a4a; }
        .error { background: #5a2d2d; border: 1px solid #8a4a4a; }
        .info { background: #2d2d5a; border: 1px solid #4a4a8a; }
        .warning { background: #5a5a2d; border: 1px solid #8a8a4a; }
        button { padding: 8px 16px; margin: 5px; background: #333; color: #00ff00; border: 1px solid #555; cursor: pointer; border-radius: 3px; }
        button:hover { background: #444; }
        button:disabled { background: #222; color: #666; cursor: not-allowed; }
        pre { background: #111; padding: 10px; overflow-x: auto; border: 1px solid #333; font-size: 12px; }
        .status-grid { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 15px; margin: 15px 0; }
        .status-card { background: #444; padding: 15px; border-radius: 5px; }
        .metric { margin: 5px 0; font-size: 14px; }
        .indicator { display: inline-block; width: 10px; height: 10px; border-radius: 50%; margin-right: 8px; }
        .green { background: #4a8a4a; }
        .red { background: #8a4a4a; }
        .yellow { background: #8a8a4a; }
        .gray { background: #666; }
        .action-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 10px; margin: 15px 0; }
        .action-card { background: #333; padding: 12px; border-radius: 5px; border: 1px solid #555; }
        .action-card h4 { margin: 0 0 10px 0; color: #00ff00; }
        .logs { height: 150px; overflow-y: scroll; background: #111; padding: 10px; border: 1px solid #333; font-size: 11px; }
        .log-entry { margin: 2px 0; padding: 2px 5px; border-radius: 3px; }
    </style>
</head>
<body>
    <div class="container">
        <h1>üé£ React Hooks Test Suite</h1>
        <p>Testing clean React hooks for game state, actions, and connection management</p>

        <div class="test-section">
            <h2>Hook Integration Setup</h2>
            <button onclick="initializeAll()" id="initBtn">Initialize Services & Hooks</button>
            <button onclick="resetAll()" id="resetBtn" disabled>Reset All</button>
            <div id="init-status" class="test-result info">Not initialized</div>
        </div>

        <div class="test-section">
            <h2>useGameState Hook Demo</h2>
            <div class="hook-demo">
                <h3>Game State Monitor</h3>
                <div class="status-grid">
                    <div class="status-card">
                        <h4>Connection State</h4>
                        <div id="connection-state">Not loaded</div>
                    </div>
                    <div class="status-card">
                        <h4>Game Phase</h4>
                        <div id="game-phase">Not loaded</div>
                    </div>
                    <div class="status-card">
                        <h4>Player State</h4>
                        <div id="player-state">Not loaded</div>
                    </div>
                </div>
                <button onclick="testGameStateHook()">Test useGameState</button>
                <button onclick="testGameStateSlice()">Test useGameStateSlice</button>
                <button onclick="testPhaseState()">Test usePhaseState</button>
                <div id="gamestate-results"></div>
            </div>
        </div>

        <div class="test-section">
            <h2>useGameActions Hook Demo</h2>
            <div class="hook-demo">
                <h3>Available Actions</h3>
                <div class="action-grid" id="actions-grid">
                    <!-- Actions will be populated here -->
                </div>
                <button onclick="testGameActionsHook()">Test useGameActions</button>
                <button onclick="testPhaseActions()">Test usePhaseActions</button>
                <button onclick="testActionAvailability()">Test Action Availability</button>
                <div id="gameactions-results"></div>
            </div>
        </div>

        <div class="test-section">
            <h2>useConnectionStatus Hook Demo</h2>
            <div class="hook-demo">
                <h3>Connection Monitor</h3>
                <div class="status-grid">
                    <div class="status-card">
                        <h4>Connection Status</h4>
                        <div id="connection-status">Not loaded</div>
                    </div>
                    <div class="status-card">
                        <h4>Network Metrics</h4>
                        <div id="network-metrics">Not loaded</div>
                    </div>
                    <div class="status-card">
                        <h4>Connection Quality</h4>
                        <div id="connection-quality">Not loaded</div>
                    </div>
                </div>
                <button onclick="testConnectionStatusHook()">Test useConnectionStatus</button>
                <button onclick="testNetworkStatus()">Test useNetworkStatus</button>
                <button onclick="testConnectionQuality()">Test Connection Quality</button>
                <div id="connection-results"></div>
            </div>
        </div>

        <div class="test-section">
            <h2>Hook Integration Tests</h2>
            <button onclick="runIntegrationTests()">Run All Integration Tests</button>
            <div id="integration-results"></div>
        </div>

        <div class="test-section">
            <h2>Live Hook Logs</h2>
            <button onclick="clearLogs()">Clear Logs</button>
            <div id="hook-logs" class="logs"></div>
        </div>

        <div class="test-section">
            <h2>Performance Testing</h2>
            <button onclick="testPerformance()">Test Hook Performance</button>
            <button onclick="testMemoryLeaks()">Test Memory Leaks</button>
            <div id="performance-results"></div>
        </div>
    </div>

    <!-- React and Hooks Testing -->
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    
    <script type="module">
        // Import our services and hooks
        import { initializeServices, serviceIntegration } from './src/services/index.js';
        
        // Note: In a real React app, these would be imported normally
        // For this test, we'll simulate the hook behavior without actual React rendering
        
        let isInitialized = false;
        let gameStateCallbacks = new Set();
        let connectionCallbacks = new Set();
        let logCounter = 0;

        // Make everything available globally for testing
        window.testAPI = {
            initializeServices,
            serviceIntegration
        };

        // Simulated hook implementations for testing
        window.simulateUseGameState = function() {
            return window.testAPI.serviceIntegration.getHealthStatus().game;
        };

        window.simulateUseConnectionStatus = function() {
            return window.testAPI.serviceIntegration.getHealthStatus().network;
        };

        // Event logging
        function addLog(message, type = 'info') {
            const logsDiv = document.getElementById('hook-logs');
            const timestamp = new Date().toLocaleTimeString();
            const div = document.createElement('div');
            div.className = `log-entry ${type}`;
            div.textContent = `[${timestamp}] ${message}`;
            logsDiv.appendChild(div);
            logsDiv.scrollTop = logsDiv.scrollHeight;
            logCounter++;
        }

        // Test functions
        window.initializeAll = async function() {
            try {
                document.getElementById('initBtn').disabled = true;
                addLog('üöÄ Initializing services for hook testing...', 'info');
                
                await window.testAPI.initializeServices();
                
                isInitialized = true;
                document.getElementById('resetBtn').disabled = false;
                updateInitStatus('‚úÖ Services initialized - Hooks ready for testing', 'success');
                
                // Start monitoring
                startStateMonitoring();
                
                addLog('‚úÖ Hook testing environment ready', 'success');
                
            } catch (error) {
                updateInitStatus(`‚ùå Initialization failed: ${error.message}`, 'error');
                addLog(`‚ùå Initialization error: ${error.message}`, 'error');
                document.getElementById('initBtn').disabled = false;
            }
        };

        window.resetAll = function() {
            try {
                addLog('üîÑ Resetting all services...', 'warning');
                
                window.testAPI.serviceIntegration.destroy();
                isInitialized = false;
                
                // Clear displays
                document.getElementById('connection-state').textContent = 'Not loaded';
                document.getElementById('game-phase').textContent = 'Not loaded';
                document.getElementById('player-state').textContent = 'Not loaded';
                document.getElementById('connection-status').textContent = 'Not loaded';
                document.getElementById('network-metrics').textContent = 'Not loaded';
                document.getElementById('connection-quality').textContent = 'Not loaded';
                
                // Reset buttons
                document.getElementById('initBtn').disabled = false;
                document.getElementById('resetBtn').disabled = true;
                
                updateInitStatus('Reset complete - Ready to reinitialize', 'info');
                addLog('‚úÖ Reset complete', 'success');
                
            } catch (error) {
                addLog(`‚ùå Reset error: ${error.message}`, 'error');
            }
        };

        window.testGameStateHook = function() {
            if (!isInitialized) {
                addResult('gamestate-results', '‚ö†Ô∏è Services not initialized', 'warning');
                return;
            }

            try {
                addLog('üß™ Testing useGameState hook simulation...', 'info');
                
                // Simulate useGameState behavior
                const gameState = window.simulateUseGameState();
                
                addResult('gamestate-results', `‚úÖ useGameState simulation successful`, 'success');
                addResult('gamestate-results', `Phase: ${gameState.phase}, Connected: ${gameState.connected}`, 'info');
                
                // Update display
                updateGameStateDisplay(gameState);
                
                addLog('‚úÖ useGameState test completed', 'success');
                
            } catch (error) {
                addResult('gamestate-results', `‚ùå useGameState test failed: ${error.message}`, 'error');
                addLog(`‚ùå useGameState test error: ${error.message}`, 'error');
            }
        };

        window.testGameStateSlice = function() {
            if (!isInitialized) {
                addResult('gamestate-results', '‚ö†Ô∏è Services not initialized', 'warning');
                return;
            }

            try {
                addLog('üß™ Testing useGameStateSlice simulation...', 'info');
                
                const health = window.testAPI.serviceIntegration.getHealthStatus();
                
                // Simulate slice selectors
                const connectionSlice = {
                    isConnected: health.game.connected,
                    phase: health.game.phase,
                    playersCount: health.game.playersCount
                };
                
                addResult('gamestate-results', `‚úÖ useGameStateSlice simulation successful`, 'success');
                addResult('gamestate-results', `Connection slice: ${JSON.stringify(connectionSlice)}`, 'info');
                
                addLog('‚úÖ useGameStateSlice test completed', 'success');
                
            } catch (error) {
                addResult('gamestate-results', `‚ùå useGameStateSlice test failed: ${error.message}`, 'error');
                addLog(`‚ùå useGameStateSlice test error: ${error.message}`, 'error');
            }
        };

        window.testPhaseState = function() {
            try {
                addLog('üß™ Testing usePhaseState simulation...', 'info');
                
                const health = window.testAPI.serviceIntegration.getHealthStatus();
                const currentPhase = health.game.phase;
                
                // Simulate phase-specific state
                const phaseState = currentPhase === 'waiting' ? {
                    phase: currentPhase,
                    ready: health.game.connected
                } : null;
                
                addResult('gamestate-results', `‚úÖ usePhaseState simulation successful`, 'success');
                addResult('gamestate-results', `Phase state for '${currentPhase}': ${JSON.stringify(phaseState)}`, 'info');
                
                addLog('‚úÖ usePhaseState test completed', 'success');
                
            } catch (error) {
                addResult('gamestate-results', `‚ùå usePhaseState test failed: ${error.message}`, 'error');
                addLog(`‚ùå usePhaseState test error: ${error.message}`, 'error');
            }
        };

        window.testGameActionsHook = function() {
            if (!isInitialized) {
                addResult('gameactions-results', '‚ö†Ô∏è Services not initialized', 'warning');
                return;
            }

            try {
                addLog('üß™ Testing useGameActions hook simulation...', 'info');
                
                // Simulate available actions based on current state
                const health = window.testAPI.serviceIntegration.getHealthStatus();
                const mockActions = {
                    connectToRoom: health.game.connected ? null : 'Available',
                    disconnectFromRoom: health.game.connected ? 'Available' : null,
                    triggerRecovery: 'Always available',
                    emergencyReset: 'Always available'
                };
                
                updateActionsDisplay(mockActions);
                
                addResult('gameactions-results', `‚úÖ useGameActions simulation successful`, 'success');
                addResult('gameactions-results', `Available actions: ${Object.keys(mockActions).filter(k => mockActions[k]).length}`, 'info');
                
                addLog('‚úÖ useGameActions test completed', 'success');
                
            } catch (error) {
                addResult('gameactions-results', `‚ùå useGameActions test failed: ${error.message}`, 'error');
                addLog(`‚ùå useGameActions test error: ${error.message}`, 'error');
            }
        };

        window.testPhaseActions = function() {
            try {
                addLog('üß™ Testing usePhaseActions simulation...', 'info');
                
                const health = window.testAPI.serviceIntegration.getHealthStatus();
                const phase = health.game.phase;
                
                const phaseSpecificActions = {
                    waiting: ['connectToRoom'],
                    preparation: ['acceptRedeal', 'declineRedeal'],
                    declaration: ['makeDeclaration'],
                    turn: ['playPieces'],
                    scoring: ['startNextRound']
                };
                
                const availableActions = phaseSpecificActions[phase] || [];
                
                addResult('gameactions-results', `‚úÖ usePhaseActions simulation successful`, 'success');
                addResult('gameactions-results', `Phase '${phase}' actions: ${availableActions.join(', ')}`, 'info');
                
                addLog('‚úÖ usePhaseActions test completed', 'success');
                
            } catch (error) {
                addResult('gameactions-results', `‚ùå usePhaseActions test failed: ${error.message}`, 'error');
                addLog(`‚ùå usePhaseActions test error: ${error.message}`, 'error');
            }
        };

        window.testActionAvailability = function() {
            try {
                addLog('üß™ Testing useActionAvailability simulation...', 'info');
                
                const health = window.testAPI.serviceIntegration.getHealthStatus();
                
                const availability = {
                    canConnect: !health.game.connected,
                    canDisconnect: health.game.connected,
                    needsRecovery: !health.overall.healthy,
                    hasErrors: health.errors.length > 0
                };
                
                addResult('gameactions-results', `‚úÖ useActionAvailability simulation successful`, 'success');
                addResult('gameactions-results', `Availability: ${JSON.stringify(availability)}`, 'info');
                
                addLog('‚úÖ useActionAvailability test completed', 'success');
                
            } catch (error) {
                addResult('gameactions-results', `‚ùå useActionAvailability test failed: ${error.message}`, 'error');
                addLog(`‚ùå useActionAvailability test error: ${error.message}`, 'error');
            }
        };

        window.testConnectionStatusHook = function() {
            if (!isInitialized) {
                addResult('connection-results', '‚ö†Ô∏è Services not initialized', 'warning');
                return;
            }

            try {
                addLog('üß™ Testing useConnectionStatus hook simulation...', 'info');
                
                const connectionState = window.simulateUseConnectionStatus();
                
                updateConnectionStatusDisplay(connectionState);
                
                addResult('connection-results', `‚úÖ useConnectionStatus simulation successful`, 'success');
                addResult('connection-results', `Status: ${connectionState.status}, Connections: ${connectionState.connections}`, 'info');
                
                addLog('‚úÖ useConnectionStatus test completed', 'success');
                
            } catch (error) {
                addResult('connection-results', `‚ùå useConnectionStatus test failed: ${error.message}`, 'error');
                addLog(`‚ùå useConnectionStatus test error: ${error.message}`, 'error');
            }
        };

        window.testNetworkStatus = function() {
            try {
                addLog('üß™ Testing useNetworkStatus simulation...', 'info');
                
                const health = window.testAPI.serviceIntegration.getHealthStatus();
                const networkStatus = health.network;
                
                updateNetworkMetricsDisplay(networkStatus);
                
                addResult('connection-results', `‚úÖ useNetworkStatus simulation successful`, 'success');
                addResult('connection-results', `Network healthy: ${networkStatus.healthy}`, 'info');
                
                addLog('‚úÖ useNetworkStatus test completed', 'success');
                
            } catch (error) {
                addResult('connection-results', `‚ùå useNetworkStatus test failed: ${error.message}`, 'error');
                addLog(`‚ùå useNetworkStatus test error: ${error.message}`, 'error');
            }
        };

        window.testConnectionQuality = function() {
            try {
                addLog('üß™ Testing useConnectionQuality simulation...', 'info');
                
                const health = window.testAPI.serviceIntegration.getHealthStatus();
                
                // Simulate connection quality calculation
                const quality = {
                    score: health.network.healthy ? 85 : 25,
                    level: health.network.healthy ? 'good' : 'poor',
                    latency: null,
                    isStable: health.metrics.totalErrors < 3,
                    hasQueueBacklog: health.network.queuedMessages > 0
                };
                
                updateConnectionQualityDisplay(quality);
                
                addResult('connection-results', `‚úÖ useConnectionQuality simulation successful`, 'success');
                addResult('connection-results', `Quality: ${quality.level} (${quality.score}/100)`, 'info');
                
                addLog('‚úÖ useConnectionQuality test completed', 'success');
                
            } catch (error) {
                addResult('connection-results', `‚ùå useConnectionQuality test failed: ${error.message}`, 'error');
                addLog(`‚ùå useConnectionQuality test error: ${error.message}`, 'error');
            }
        };

        window.runIntegrationTests = async function() {
            if (!isInitialized) {
                addResult('integration-results', '‚ö†Ô∏è Services not initialized', 'warning');
                return;
            }

            const resultsDiv = document.getElementById('integration-results');
            resultsDiv.innerHTML = '<div class="test-result info">Running integration tests...</div>';

            const tests = [
                testHookStateConsistency,
                testHookPerformance,
                testHookMemoryManagement,
                testErrorHandling
            ];

            let passedTests = 0;
            
            for (const test of tests) {
                try {
                    const result = await test();
                    resultsDiv.innerHTML += `<div class="test-result ${result.success ? 'success' : 'error'}">
                        ${result.name}: ${result.success ? 'PASS' : 'FAIL'}
                        ${result.message ? `<br>${result.message}` : ''}
                    </div>`;
                    if (result.success) passedTests++;
                } catch (error) {
                    resultsDiv.innerHTML += `<div class="test-result error">
                        ${test.name || 'Unknown Test'}: ERROR - ${error.message}
                    </div>`;
                }
            }

            resultsDiv.innerHTML += `<div class="test-result ${passedTests === tests.length ? 'success' : 'warning'}">
                Integration Test Summary: ${passedTests}/${tests.length} tests passed
            </div>`;
        };

        window.testPerformance = function() {
            addLog('üß™ Testing hook performance...', 'info');
            
            const startTime = performance.now();
            
            // Simulate multiple hook calls
            for (let i = 0; i < 1000; i++) {
                window.simulateUseGameState();
                window.simulateUseConnectionStatus();
            }
            
            const endTime = performance.now();
            const duration = endTime - startTime;
            
            addResult('performance-results', `‚úÖ Performance test completed`, 'success');
            addResult('performance-results', `1000 hook calls took ${duration.toFixed(2)}ms (${(duration/1000).toFixed(4)}ms per call)`, 'info');
            
            addLog(`‚úÖ Performance test: ${duration.toFixed(2)}ms for 1000 calls`, 'success');
        };

        window.testMemoryLeaks = function() {
            addLog('üß™ Testing memory leak prevention...', 'info');
            
            // Simulate hook cleanup
            const memoryBefore = performance.memory ? performance.memory.usedJSHeapSize : 'Unknown';
            
            // Note: In a real React app, this would test actual component unmounting
            // For this demo, we simulate the cleanup behavior
            
            addResult('performance-results', `‚úÖ Memory leak test simulated`, 'success');
            addResult('performance-results', `Memory usage: ${typeof memoryBefore === 'number' ? Math.round(memoryBefore/1024/1024) + 'MB' : memoryBefore}`, 'info');
            addResult('performance-results', `Note: Full memory testing requires React component lifecycle`, 'info');
            
            addLog('‚úÖ Memory leak test completed (simulated)', 'success');
        };

        window.clearLogs = function() {
            document.getElementById('hook-logs').innerHTML = '';
            logCounter = 0;
            addLog('üìù Logs cleared', 'info');
        };

        // Helper functions
        function updateInitStatus(message, type) {
            const statusDiv = document.getElementById('init-status');
            statusDiv.className = `test-result ${type}`;
            statusDiv.textContent = message;
        }

        function addResult(containerId, message, type = 'info') {
            const container = document.getElementById(containerId);
            const div = document.createElement('div');
            div.className = `test-result ${type}`;
            div.innerHTML = message;
            container.appendChild(div);
        }

        function updateGameStateDisplay(gameState) {
            document.getElementById('connection-state').innerHTML = `
                <div class="metric"><span class="indicator ${gameState.connected ? 'green' : 'red'}"></span>Connected: ${gameState.connected}</div>
                <div class="metric">Room: ${gameState.roomId || 'None'}</div>
                <div class="metric">Players: ${gameState.playersCount}</div>
            `;
            
            document.getElementById('game-phase').innerHTML = `
                <div class="metric">Phase: ${gameState.phase}</div>
                <div class="metric">Status: ${gameState.status}</div>
                <div class="metric">Healthy: ${gameState.healthy}</div>
            `;
            
            document.getElementById('player-state').innerHTML = `
                <div class="metric">Player: ${gameState.playerName || 'None'}</div>
                <div class="metric">Turn: N/A</div>
                <div class="metric">Actions: N/A</div>
            `;
        }

        function updateActionsDisplay(actions) {
            const grid = document.getElementById('actions-grid');
            grid.innerHTML = '';
            
            Object.entries(actions).forEach(([action, status]) => {
                const card = document.createElement('div');
                card.className = 'action-card';
                card.innerHTML = `
                    <h4>${action}</h4>
                    <div class="metric">
                        <span class="indicator ${status ? 'green' : 'gray'}"></span>
                        ${status || 'Not available'}
                    </div>
                `;
                grid.appendChild(card);
            });
        }

        function updateConnectionStatusDisplay(connectionState) {
            document.getElementById('connection-status').innerHTML = `
                <div class="metric"><span class="indicator ${connectionState.healthy ? 'green' : 'red'}"></span>Status: ${connectionState.status}</div>
                <div class="metric">Connections: ${connectionState.connections}</div>
                <div class="metric">Queued: ${connectionState.queuedMessages}</div>
            `;
        }

        function updateNetworkMetricsDisplay(networkStatus) {
            document.getElementById('network-metrics').innerHTML = `
                <div class="metric">Healthy: ${networkStatus.healthy}</div>
                <div class="metric">Connections: ${networkStatus.connections}</div>
                <div class="metric">Queued Messages: ${networkStatus.queuedMessages}</div>
            `;
        }

        function updateConnectionQualityDisplay(quality) {
            const levelColors = {
                excellent: 'green',
                good: 'green',
                fair: 'yellow',
                poor: 'red',
                offline: 'gray'
            };
            
            document.getElementById('connection-quality').innerHTML = `
                <div class="metric"><span class="indicator ${levelColors[quality.level]}"></span>Quality: ${quality.level}</div>
                <div class="metric">Score: ${quality.score}/100</div>
                <div class="metric">Stable: ${quality.isStable}</div>
            `;
        }

        function startStateMonitoring() {
            setInterval(() => {
                if (isInitialized) {
                    try {
                        const gameState = window.simulateUseGameState();
                        const connectionState = window.simulateUseConnectionStatus();
                        updateGameStateDisplay(gameState);
                        updateConnectionStatusDisplay(connectionState);
                    } catch (error) {
                        // Silent monitoring errors
                    }
                }
            }, 2000);
        }

        // Integration test functions
        async function testHookStateConsistency() {
            const gameState1 = window.simulateUseGameState();
            const gameState2 = window.simulateUseGameState();
            
            return {
                name: 'Hook State Consistency',
                success: gameState1.phase === gameState2.phase && gameState1.connected === gameState2.connected,
                message: 'Multiple hook calls return consistent state'
            };
        }

        async function testHookPerformance() {
            const startTime = performance.now();
            for (let i = 0; i < 100; i++) {
                window.simulateUseGameState();
            }
            const duration = performance.now() - startTime;
            
            return {
                name: 'Hook Performance',
                success: duration < 50, // Should complete 100 calls in under 50ms
                message: `100 calls took ${duration.toFixed(2)}ms`
            };
        }

        async function testHookMemoryManagement() {
            // Simulate hook cleanup patterns
            return {
                name: 'Hook Memory Management',
                success: true, // Simulated - would need real React for full test
                message: 'Cleanup patterns implemented (simulated)'
            };
        }

        async function testErrorHandling() {
            try {
                // Test error boundary integration
                const health = window.testAPI.serviceIntegration.getHealthStatus();
                return {
                    name: 'Error Handling',
                    success: typeof health.errors === 'object',
                    message: 'Error state accessible through hooks'
                };
            } catch (error) {
                return {
                    name: 'Error Handling',
                    success: false,
                    message: `Error handling test failed: ${error.message}`
                };
            }
        }

        // Initialize on load
        addLog('üé£ React Hooks Test Suite Loaded', 'success');
        addLog('üìù Note: This simulates hook behavior without actual React rendering', 'info');
    </script>
</body>
</html>