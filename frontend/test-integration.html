<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Service Integration Test</title>
    <style>
        body { font-family: monospace; padding: 20px; background: #1a1a1a; color: #00ff00; }
        .container { max-width: 1400px; margin: 0 auto; }
        .test-section { margin: 20px 0; padding: 15px; border: 1px solid #333; background: #222; }
        .test-result { margin: 10px 0; padding: 10px; border-radius: 4px; }
        .success { background: #2d5a2d; border: 1px solid #4a8a4a; }
        .error { background: #5a2d2d; border: 1px solid #8a4a4a; }
        .info { background: #2d2d5a; border: 1px solid #4a4a8a; }
        .warning { background: #5a5a2d; border: 1px solid #8a8a4a; }
        button { padding: 10px 20px; margin: 5px; background: #333; color: #00ff00; border: 1px solid #555; cursor: pointer; }
        button:hover { background: #444; }
        button:disabled { background: #222; color: #666; cursor: not-allowed; }
        pre { background: #111; padding: 10px; overflow-x: auto; border: 1px solid #333; font-size: 12px; }
        .status-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; }
        .status-panel { background: #333; padding: 15px; border-radius: 5px; }
        .health-indicator { display: inline-block; width: 12px; height: 12px; border-radius: 50%; margin-right: 8px; }
        .healthy { background: #4a8a4a; }
        .unhealthy { background: #8a4a4a; }
        .unknown { background: #666; }
        .metric { margin: 5px 0; font-size: 14px; }
        .live-events { height: 300px; overflow-y: scroll; background: #111; padding: 10px; border: 1px solid #333; font-size: 12px; }
        .event-item { margin: 3px 0; padding: 3px 6px; border-radius: 3px; }
    </style>
</head>
<body>
    <div class="container">
        <h1>üîó Service Integration Test Suite</h1>
        <p>Testing unified service layer, error handling, and recovery coordination</p>

        <div class="test-section">
            <h2>Integration Control Panel</h2>
            <button onclick="initializeIntegration()" id="initBtn">Initialize Integration</button>
            <button onclick="checkHealth()" id="healthBtn" disabled>Check Health</button>
            <button onclick="simulateError()" id="errorBtn" disabled>Simulate Error</button>
            <button onclick="triggerRecovery()" id="recoveryBtn" disabled>Trigger Recovery</button>
            <button onclick="emergencyReset()" id="resetBtn" disabled>Emergency Reset</button>
            <button onclick="destroyIntegration()" id="destroyBtn" disabled>Destroy</button>
        </div>

        <div class="status-grid">
            <div class="status-panel">
                <h3>System Health</h3>
                <div id="health-status">Not initialized</div>
            </div>
            <div class="status-panel">
                <h3>Service Metrics</h3>
                <div id="metrics-display">No metrics available</div>
            </div>
        </div>

        <div class="test-section">
            <h2>Room Connection Test</h2>
            <input type="text" id="roomIdInput" placeholder="Room ID" value="test-integration-room" 
                   style="background: #333; color: #00ff00; border: 1px solid #555; padding: 8px; margin: 5px;">
            <input type="text" id="playerNameInput" placeholder="Player Name" value="IntegrationTester"
                   style="background: #333; color: #00ff00; border: 1px solid #555; padding: 8px; margin: 5px;">
            <button onclick="connectRoom()" id="connectBtn" disabled>Connect to Room</button>
            <button onclick="disconnectRoom()" id="disconnectBtn" disabled>Disconnect</button>
            <div id="connection-status" class="test-result info">Not connected</div>
        </div>

        <div class="test-section">
            <h2>Error Simulation & Recovery</h2>
            <select id="errorTypeSelect" style="background: #333; color: #00ff00; border: 1px solid #555; padding: 8px; margin: 5px;">
                <option value="NETWORK_CONNECTION_FAILED">Network Connection Failed</option>
                <option value="SEQUENCE_GAP">Sequence Gap</option>
                <option value="GAME_STATE_ERROR">Game State Error</option>
                <option value="CONNECTION_LOST">Connection Lost</option>
                <option value="CUSTOM_ERROR">Custom Error</option>
            </select>
            <button onclick="simulateSpecificError()" id="specificErrorBtn" disabled>Simulate Selected Error</button>
            <div id="error-simulation-results"></div>
        </div>

        <div class="test-section">
            <h2>Integration Tests</h2>
            <button onclick="runAllTests()" id="testBtn" disabled>Run All Tests</button>
            <div id="test-results"></div>
        </div>

        <div class="test-section">
            <h2>Live Event Monitor</h2>
            <button onclick="clearEvents()">Clear Events</button>
            <div id="live-events" class="live-events"></div>
        </div>

        <div class="test-section">
            <h2>Detailed Status</h2>
            <button onclick="showDetailedStatus()">Refresh Detailed Status</button>
            <div id="detailed-status"></div>
        </div>
    </div>

    <script type="module">
        // Import services
        import { 
            initializeServices, 
            getServicesHealth, 
            connectToRoom, 
            disconnectFromRoom,
            triggerRecovery as serviceTriggerRecovery,
            emergencyReset as serviceEmergencyReset,
            cleanupServices,
            serviceIntegration 
        } from './src/services/index.js';

        // Make available globally for testing
        window.serviceIntegration = serviceIntegration;
        window.servicesAPI = {
            initializeServices,
            getServicesHealth,
            connectToRoom,
            disconnectFromRoom,
            triggerRecovery: serviceTriggerRecovery,
            emergencyReset: serviceEmergencyReset,
            cleanupServices
        };

        let isInitialized = false;
        let isConnected = false;
        let eventCounter = 0;

        // Setup event listeners
        function setupEventListeners() {
            // Integration events
            serviceIntegration.addEventListener('initialized', (event) => {
                addEvent('‚úÖ Integration Initialized', 'success');
                enableButtons();
                isInitialized = true;
                checkHealth();
            });

            serviceIntegration.addEventListener('error', (event) => {
                const { error } = event.detail;
                addEvent(`üö® Error [${error.severity}]: ${error.message}`, 'error');
                updateErrorCount();
            });

            serviceIntegration.addEventListener('recoveryCompleted', (event) => {
                const { recoveryResult } = event.detail;
                addEvent(`üîÑ Recovery ${recoveryResult.success ? 'Successful' : 'Failed'}: ${recoveryResult.appliedStrategies.join(', ')}`, 
                         recoveryResult.success ? 'success' : 'error');
            });

            serviceIntegration.addEventListener('healthIssue', (event) => {
                const { healthStatus } = event.detail;
                addEvent(`‚ö†Ô∏è Health Issues: ${healthStatus.overall.issues.join(', ')}`, 'warning');
            });

            serviceIntegration.addEventListener('roomConnected', (event) => {
                const { roomId, playerName } = event.detail;
                addEvent(`üîó Connected to room ${roomId} as ${playerName}`, 'success');
                isConnected = true;
                updateConnectionStatus(`Connected to ${roomId} as ${playerName}`, 'success');
                document.getElementById('connectBtn').disabled = true;
                document.getElementById('disconnectBtn').disabled = false;
            });

            serviceIntegration.addEventListener('roomDisconnected', (event) => {
                const { roomId } = event.detail;
                addEvent(`üîå Disconnected from room ${roomId}`, 'info');
                isConnected = false;
                updateConnectionStatus('Not connected', 'info');
                document.getElementById('connectBtn').disabled = false;
                document.getElementById('disconnectBtn').disabled = true;
            });

            serviceIntegration.addEventListener('emergencyReset', (event) => {
                addEvent('üö® Emergency Reset Completed', 'warning');
                resetUI();
            });

            serviceIntegration.addEventListener('errorThresholdExceeded', (event) => {
                const { errorCount, windowMs } = event.detail;
                addEvent(`‚ö†Ô∏è Error Threshold Exceeded: ${errorCount} errors in ${windowMs}ms`, 'warning');
            });
        }

        // UI Functions
        window.initializeIntegration = async function() {
            try {
                addEvent('üöÄ Initializing service integration...', 'info');
                document.getElementById('initBtn').disabled = true;
                
                await window.servicesAPI.initializeServices();
                
            } catch (error) {
                addEvent(`‚ùå Initialization failed: ${error.message}`, 'error');
                document.getElementById('initBtn').disabled = false;
            }
        };

        window.checkHealth = function() {
            if (!isInitialized) {
                addEvent('‚ö†Ô∏è Integration not initialized', 'warning');
                return;
            }

            const health = window.servicesAPI.getServicesHealth();
            updateHealthStatus(health);
            updateMetrics(health.metrics);
            addEvent(`ü©∫ Health check completed - Overall: ${health.overall.healthy ? 'Healthy' : 'Issues detected'}`, 
                    health.overall.healthy ? 'success' : 'warning');
        };

        window.connectRoom = async function() {
            if (!isInitialized) {
                addEvent('‚ö†Ô∏è Integration not initialized', 'warning');
                return;
            }

            const roomId = document.getElementById('roomIdInput').value;
            const playerName = document.getElementById('playerNameInput').value;

            if (!roomId || !playerName) {
                addEvent('‚ö†Ô∏è Please enter room ID and player name', 'warning');
                return;
            }

            try {
                addEvent(`üîó Connecting to room ${roomId}...`, 'info');
                await window.servicesAPI.connectToRoom(roomId, playerName);
            } catch (error) {
                addEvent(`‚ùå Connection failed: ${error.message}`, 'error');
                updateConnectionStatus(`Connection failed: ${error.message}`, 'error');
            }
        };

        window.disconnectRoom = async function() {
            try {
                addEvent('üîå Disconnecting from room...', 'info');
                await window.servicesAPI.disconnectFromRoom();
            } catch (error) {
                addEvent(`‚ùå Disconnection failed: ${error.message}`, 'error');
            }
        };

        window.simulateError = async function() {
            if (!isInitialized) {
                addEvent('‚ö†Ô∏è Integration not initialized', 'warning');
                return;
            }

            // Simulate a network error
            addEvent('üß™ Simulating network connection error...', 'info');
            
            // Manually trigger error through integration layer
            const mockError = {
                type: 'SIMULATED_ERROR',
                severity: 'HIGH',
                message: 'Simulated error for testing',
                source: 'TestSuite',
                timestamp: Date.now(),
                context: { test: true }
            };

            // Access private method through event
            serviceIntegration.dispatchEvent(new CustomEvent('error', {
                detail: { error: mockError, timestamp: Date.now() }
            }));
        };

        window.simulateSpecificError = function() {
            const errorType = document.getElementById('errorTypeSelect').value;
            addEvent(`üß™ Simulating ${errorType}...`, 'info');
            
            const mockError = {
                type: errorType,
                severity: 'HIGH',
                message: `Simulated ${errorType} for testing`,
                source: 'TestSuite',
                timestamp: Date.now(),
                context: { test: true, errorType }
            };

            serviceIntegration.dispatchEvent(new CustomEvent('error', {
                detail: { error: mockError, timestamp: Date.now() }
            }));
        };

        window.triggerRecovery = async function() {
            if (!isInitialized) {
                addEvent('‚ö†Ô∏è Integration not initialized', 'warning');
                return;
            }

            try {
                addEvent('üîÑ Triggering manual recovery...', 'info');
                const result = await window.servicesAPI.triggerRecovery();
                
                const resultDiv = document.getElementById('error-simulation-results');
                resultDiv.innerHTML = `<div class="test-result ${result.success ? 'success' : 'error'}">
                    Recovery ${result.success ? 'successful' : 'failed'}<br>
                    Applied strategies: ${result.appliedStrategies.join(', ') || 'none'}<br>
                    ${result.error ? `Error: ${result.error}` : ''}
                </div>`;
                
            } catch (error) {
                addEvent(`‚ùå Recovery trigger failed: ${error.message}`, 'error');
            }
        };

        window.emergencyReset = async function() {
            if (!confirm('Are you sure you want to perform an emergency reset? This will destroy all services.')) {
                return;
            }

            try {
                addEvent('üö® Performing emergency reset...', 'warning');
                await window.servicesAPI.emergencyReset();
                
            } catch (error) {
                addEvent(`‚ùå Emergency reset failed: ${error.message}`, 'error');
            }
        };

        window.destroyIntegration = function() {
            if (!confirm('Are you sure you want to destroy the integration layer?')) {
                return;
            }

            try {
                addEvent('üóëÔ∏è Destroying integration layer...', 'warning');
                window.servicesAPI.cleanupServices();
                resetUI();
                addEvent('‚úÖ Integration layer destroyed', 'info');
            } catch (error) {
                addEvent(`‚ùå Destroy failed: ${error.message}`, 'error');
            }
        };

        window.runAllTests = async function() {
            if (!isInitialized) {
                addEvent('‚ö†Ô∏è Integration not initialized', 'warning');
                return;
            }

            const resultsDiv = document.getElementById('test-results');
            resultsDiv.innerHTML = '<div class="test-result info">Running integration tests...</div>';

            const tests = [
                testHealthCheck,
                testErrorHandling,
                testRecoverySystem,
                testMetricsTracking
            ];

            let passedTests = 0;
            let totalTests = tests.length;

            for (const test of tests) {
                try {
                    const result = await test();
                    resultsDiv.innerHTML += `<div class="test-result ${result.success ? 'success' : 'error'}">
                        ${result.name}: ${result.success ? 'PASS' : 'FAIL'}
                        ${result.message ? `<br>${result.message}` : ''}
                    </div>`;
                    if (result.success) passedTests++;
                } catch (error) {
                    resultsDiv.innerHTML += `<div class="test-result error">
                        ${test.name || 'Unknown Test'}: ERROR - ${error.message}
                    </div>`;
                }
            }

            resultsDiv.innerHTML += `<div class="test-result ${passedTests === totalTests ? 'success' : 'warning'}">
                Test Summary: ${passedTests}/${totalTests} tests passed
            </div>`;
        };

        window.showDetailedStatus = function() {
            if (!isInitialized) {
                document.getElementById('detailed-status').innerHTML = 
                    '<div class="test-result warning">Integration not initialized</div>';
                return;
            }

            const health = window.servicesAPI.getServicesHealth();
            document.getElementById('detailed-status').innerHTML = 
                `<pre>${JSON.stringify(health, null, 2)}</pre>`;
        };

        window.clearEvents = function() {
            document.getElementById('live-events').innerHTML = '';
            eventCounter = 0;
        };

        // Helper functions
        function addEvent(message, type = 'info') {
            const eventsDiv = document.getElementById('live-events');
            const timestamp = new Date().toLocaleTimeString();
            const div = document.createElement('div');
            div.className = `event-item ${type}`;
            div.textContent = `[${timestamp}] ${message}`;
            eventsDiv.appendChild(div);
            eventsDiv.scrollTop = eventsDiv.scrollHeight;
            eventCounter++;
        }

        function updateHealthStatus(health) {
            const statusDiv = document.getElementById('health-status');
            const overallIndicator = health.overall.healthy ? 'healthy' : 'unhealthy';
            
            statusDiv.innerHTML = `
                <div class="metric">
                    <span class="health-indicator ${overallIndicator}"></span>
                    Overall: ${health.overall.healthy ? 'Healthy' : 'Issues Detected'}
                </div>
                <div class="metric">
                    <span class="health-indicator ${health.network.healthy ? 'healthy' : 'unhealthy'}"></span>
                    Network: ${health.network.status} (${health.network.connections} connections)
                </div>
                <div class="metric">
                    <span class="health-indicator ${health.game.healthy ? 'healthy' : 'unhealthy'}"></span>
                    Game: ${health.game.status} (${health.game.phase})
                </div>
                <div class="metric">
                    <span class="health-indicator ${health.recovery?.healthy ? 'healthy' : health.recovery ? 'unhealthy' : 'unknown'}"></span>
                    Recovery: ${health.recovery?.status || 'Not initialized'}
                </div>
                ${health.overall.issues.length > 0 ? `<div class="metric">Issues: ${health.overall.issues.join(', ')}</div>` : ''}
            `;
        }

        function updateMetrics(metrics) {
            const metricsDiv = document.getElementById('metrics-display');
            const uptime = Math.floor((Date.now() - metrics.uptime) / 1000);
            
            metricsDiv.innerHTML = `
                <div class="metric">Uptime: ${uptime}s</div>
                <div class="metric">Total Errors: ${metrics.totalErrors}</div>
                <div class="metric">Recovery Attempts: ${metrics.recoveryAttempts}</div>
                <div class="metric">Successful Recoveries: ${metrics.successfulRecoveries}</div>
                <div class="metric">Last Health Check: ${metrics.lastHealthCheck ? new Date(metrics.lastHealthCheck).toLocaleTimeString() : 'Never'}</div>
            `;
        }

        function updateConnectionStatus(message, type) {
            const statusDiv = document.getElementById('connection-status');
            statusDiv.className = `test-result ${type}`;
            statusDiv.textContent = message;
        }

        function enableButtons() {
            const buttonIds = ['healthBtn', 'errorBtn', 'recoveryBtn', 'resetBtn', 'destroyBtn', 
                             'connectBtn', 'specificErrorBtn', 'testBtn'];
            buttonIds.forEach(id => {
                document.getElementById(id).disabled = false;
            });
        }

        function resetUI() {
            isInitialized = false;
            isConnected = false;
            
            const buttonIds = ['healthBtn', 'errorBtn', 'recoveryBtn', 'resetBtn', 'destroyBtn', 
                             'connectBtn', 'disconnectBtn', 'specificErrorBtn', 'testBtn'];
            buttonIds.forEach(id => {
                document.getElementById(id).disabled = true;
            });
            
            document.getElementById('initBtn').disabled = false;
            document.getElementById('health-status').textContent = 'Not initialized';
            document.getElementById('metrics-display').textContent = 'No metrics available';
            updateConnectionStatus('Not connected', 'info');
        }

        function updateErrorCount() {
            if (isInitialized) {
                setTimeout(checkHealth, 100); // Update health after error
            }
        }

        // Test functions
        async function testHealthCheck() {
            const health = window.servicesAPI.getServicesHealth();
            return {
                name: 'Health Check Test',
                success: health && typeof health.overall === 'object' && typeof health.overall.healthy === 'boolean',
                message: health ? `Overall healthy: ${health.overall.healthy}` : 'No health data'
            };
        }

        async function testErrorHandling() {
            const initialErrorCount = window.servicesAPI.getServicesHealth().metrics.totalErrors;
            
            // Simulate an error
            const mockError = {
                type: 'TEST_ERROR',
                severity: 'MEDIUM',
                message: 'Test error handling',
                source: 'TestSuite',
                timestamp: Date.now()
            };

            serviceIntegration.dispatchEvent(new CustomEvent('error', {
                detail: { error: mockError, timestamp: Date.now() }
            }));

            // Wait a bit for processing
            await new Promise(resolve => setTimeout(resolve, 100));
            
            const newErrorCount = window.servicesAPI.getServicesHealth().metrics.totalErrors;
            
            return {
                name: 'Error Handling Test',
                success: newErrorCount > initialErrorCount,
                message: `Error count increased from ${initialErrorCount} to ${newErrorCount}`
            };
        }

        async function testRecoverySystem() {
            try {
                const result = await window.servicesAPI.triggerRecovery('TEST_RECOVERY');
                return {
                    name: 'Recovery System Test',
                    success: result && typeof result.success === 'boolean',
                    message: `Recovery result: ${result.success ? 'success' : 'failed'}`
                };
            } catch (error) {
                return {
                    name: 'Recovery System Test',
                    success: false,
                    message: `Recovery failed: ${error.message}`
                };
            }
        }

        async function testMetricsTracking() {
            const metrics = window.servicesAPI.getServicesHealth().metrics;
            const requiredFields = ['totalErrors', 'recoveryAttempts', 'successfulRecoveries', 'uptime'];
            const hasAllFields = requiredFields.every(field => typeof metrics[field] === 'number');
            
            return {
                name: 'Metrics Tracking Test',
                success: hasAllFields,
                message: `Metrics fields present: ${Object.keys(metrics).join(', ')}`
            };
        }

        // Initialize on load
        setupEventListeners();
        addEvent('üîó Service Integration Test Suite Loaded', 'success');
    </script>
</body>
</html>